<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AIチャット</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0d1117;
      height: 100vh;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      color: #e6edf3;
      overflow: hidden;
    }

    .header {
      background: #161b22;
      padding: 1rem 2rem;
      text-align: center;
      border-bottom: 1px solid #30363d;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .header h1 {
      color: #e6edf3;
      font-size: 1.5rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    .user-info {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      margin-top: 0.5rem;
    }

    .city-selector {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .city-selector label {
      color: #e6edf3;
      font-size: 0.9rem;
      font-weight: 500;
    }

    .city-select {
      background: #0d1117;
      color: #e6edf3;
      border: 1px solid #30363d;
      border-radius: 4px;
      padding: 0.25rem 0.5rem;
      font-size: 0.9rem;
      cursor: pointer;
      transition: border-color 0.2s ease;
    }

    .city-select:focus {
      outline: none;
      border-color: #1f6feb;
    }

    .city-select option {
      background: #0d1117;
      color: #e6edf3;
    }

    .user-info span {
      color: #8b949e;
      font-size: 0.9rem;
    }

    .logout-btn {
      background: #21262d;
      color: #e6edf3;
      border: 1px solid #30363d;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .logout-btn:hover {
      background: #30363d;
      border-color: #484f58;
    }

    .chat-container {
      flex: 1;
      width: 100%;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: calc(100vh - 80px); /* ヘッダーの高さを引く */
    }

    #chat {
      flex: 1;
      background: #0d1117;
      border-radius: 0;
      padding: 1rem;
      margin-bottom: 0;
      overflow-y: auto;
      border: none;
      border-bottom: 1px solid #30363d;
      min-height: auto;
      max-height: none;
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    .msg {
      margin: 0.75rem 0;
      padding: 0.75rem 1rem;
      border-radius: 18px;
      max-width: 80%;
      word-wrap: break-word;
      animation: fadeIn 0.3s ease-in;
      line-height: 1.6;
      display: inline-block;
      width: fit-content;
      min-width: 60px;
    }

    .user {
      background: #6e7681;
      color: #ffffff;
      margin-left: auto;
      text-align: right;
      border-radius: 18px 18px 4px 18px;
      align-self: flex-end;
    }

    .ai {
      background: #21262d;
      color: #e6edf3;
      border: 1px solid #30363d;
      border-radius: 18px 18px 18px 4px;
      align-self: flex-start;
    }

    .search-result {
      background: #0c2d6b;
      border-left: 4px solid #1f6feb;
      padding: 0.75rem 1rem;
      margin: 0.75rem 0;
      border-radius: 8px;
      font-size: 0.9rem;
      color: #e6edf3;
      align-self: flex-start;
      width: fit-content;
      max-width: 80%;
    }

    .input-container {
      display: flex;
      gap: 0.5rem;
      background: #161b22;
      padding: 1rem 2rem;
      border-radius: 0;
      border: none;
      border-top: 1px solid #30363d;
      box-shadow: 0 -1px 3px rgba(0, 0, 0, 0.3);
      position: sticky;
      bottom: 0;
    }

    #input {
      flex: 1;
      padding: 0.75rem 1rem;
      border: 1px solid #30363d;
      border-radius: 8px;
      font-size: 1rem;
      outline: none;
      transition: border-color 0.2s ease;
      background: #0d1117;
      color: #e6edf3;
    }

    #input:focus {
      border-color: #1f6feb;
      box-shadow: 0 0 0 2px rgba(31, 111, 235, 0.2);
    }

    #input::placeholder {
      color: #8b949e;
    }

    #send {
      padding: 0.75rem 1.5rem;
      background: #1f6feb;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    #send:hover {
      background: #388bfd;
      transform: translateY(-1px);
    }

    #send:active {
      transform: translateY(0);
      background: #1f6feb;
    }

    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #30363d;
      border-top: 3px solid #1f6feb;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .typing-indicator {
      display: flex;
      gap: 4px;
      padding: 0.75rem 1rem;
      background: #21262d;
      border-radius: 18px 18px 18px 4px;
      margin: 0.75rem 0;
      max-width: 80%;
      border: 1px solid #30363d;
      align-self: flex-start;
      width: fit-content;
    }

    .typing-dot {
      width: 8px;
      height: 8px;
      background: #8b949e;
      border-radius: 50%;
      animation: typing 1.4s infinite ease-in-out;
    }

    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }

    @keyframes typing {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-10px); }
    }

    @media (max-width: 768px) {
      .chat-container { 
        padding: 0; 
        height: calc(100vh - 70px);
      }
      .msg { max-width: 90%; }
      .input-container { 
        flex-direction: column; 
        padding: 1rem;
      }
      .header {
        padding: 1rem;
      }
      #chat { 
        height: 100%;
        padding: 0.5rem;
      }
    }

    /* スクロールバーのカスタマイズ */
    #chat::-webkit-scrollbar {
      width: 8px;
    }

    #chat::-webkit-scrollbar-track {
      background: #0d1117;
    }

    #chat::-webkit-scrollbar-thumb {
      background: #30363d;
      border-radius: 4px;
    }

    #chat::-webkit-scrollbar-thumb:hover {
      background: #484f58;
    }
  </style>
</head>
<body>
  <div class="header">
            <h1 id="ai-title"> 無料AI学習チャット</h1>
    <div class="user-info">
      <div class="city-selector">
        <label for="city-select">都市:</label>
        <select id="city-select" class="city-select" style="background: #333; color: white; border: 1px solid #555; padding: 5px; border-radius: 4px;">
          <option value="Tokyo">東京</option>
          <option value="Osaka">大阪</option>
        </select>
      </div>
      <button onclick="showLearningSettings()" class="learning-btn" style="background: #333; color: white; border: none; padding: 8px 15px; border-radius: 5px; margin-right: 10px; cursor: pointer;">🧠 学習設定</button>
      <button onclick="showSystemStatus()" class="system-btn" style="background: #555; color: white; border: none; padding: 8px 15px; border-radius: 5px; margin-right: 10px; cursor: pointer;">🔧 システム状態</button>
      <span id="user-name">ユーザー</span>
      <button id="logout-btn" class="logout-btn">ログアウト</button>
    </div>
  </div>

  <div class="chat-container">
    <div id="chat">
      <div class="msg ai">
         こんにちは！何かお手伝いできることはありますか？<br>
        「〇〇について調べて」や「〇〇を検索して」と言えば、Google検索を開きます。<br>
        また、AIの名前変更やユーザーの呼び方変更も可能です！<br>
        例：「あなたはAIアシスタントです」「私をユーザーと呼んで」<br><br>
        <strong> 無料AI学習システム搭載：</strong><br>
        • 高度な感情分析と文脈理解<br>
        • 100,000パターンの会話データベース<br>
        • 学習機能による継続的な改善<br>
        • 検索機能とリアルタイム情報提供<br>
        • 気温・天気情報の取得<br>
        • 都市選択機能（東京・大阪）<br>
        • ユーザー命令の学習機能<br>
        • 完全無料の高度AI学習システム
      </div>
    </div>

    <div class="input-container">
      <input id="input" placeholder="メッセージを入力してください..." />
      <button id="send" style="background: #333; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">送信</button>
    </div>
  </div>

  <script>
    // 認証チェック
    function checkAuth() {
      if (localStorage.getItem('is_logged_in') !== 'true') {
        window.location.href = 'login.html';
        return false;
      }
      return true;
    }

    // ページ読み込み時の認証チェック
    if (!checkAuth()) {
      // 認証チェックに失敗した場合は処理を停止
      throw new Error('認証が必要です');
    }

    // ユーザー情報を取得して表示
    async function loadUserInfo() {
      try {
        const response = await fetch('get_user_info.php');
        const data = await response.json();
        
        if (data.success) {
          const fullName = data.data.full_name;
          document.getElementById('user-name').textContent = `ようこそ、${fullName}さん`;
          
          // ローカルストレージも更新
          localStorage.setItem('user_name', fullName);
          localStorage.setItem('user_id', data.data.id);
        } else {
          // エラーの場合はローカルストレージから取得
          const userName = localStorage.getItem('user_name') || 'ユーザー';
          document.getElementById('user-name').textContent = `ようこそ、${userName}さん`;
        }
      } catch (error) {
        console.error('ユーザー情報取得エラー:', error);
        // エラーの場合はローカルストレージから取得
        const userName = localStorage.getItem('user_name') || 'ユーザー';
        document.getElementById('user-name').textContent = `ようこそ、${userName}さん`;
      }
    }

    // ページ読み込み時にユーザー情報を取得
    loadUserInfo();

    const chat = document.getElementById("chat");
    const input = document.getElementById("input");
    const send = document.getElementById("send");

    // 10万パターンの会話組み合わせを作成
    const conversationPatterns = generateConversationPatterns();
    
    // 会話履歴を保存
    let conversationHistory = [];
    
    // 高度なコンテキスト管理システム
    class AdvancedContextManager {
      constructor() {
        this.contexts = new Map(); // ユーザーごとのコンテキスト
        this.globalContext = {
          currentTopic: '',
          userMood: 'neutral',
          conversationLength: 0,
          lastUserMessage: '',
          interests: [],
          timeOfDay: '',
          season: '',
          lastResponseType: '',
          // 新しい高度コンテキストフィールド
          topicHistory: [],
          moodTrend: [],
          conversationFlow: [],
          userPreferences: {},
          emotionalState: {},
          attentionLevel: 'normal',
          responseQuality: []
        };
      }
      
      getContext(userId = 'default') {
        if (!this.contexts.has(userId)) {
          this.contexts.set(userId, this.createNewContext());
        }
        return this.contexts.get(userId);
      }
      
      createNewContext() {
        return {
          currentTopic: '',
          userMood: 'neutral',
          conversationLength: 0,
          lastUserMessage: '',
          interests: [],
          timeOfDay: this.getTimeOfDay(),
          season: this.getCurrentSeason(),
          lastResponseType: '',
          topicHistory: [],
          moodTrend: [],
          conversationFlow: [],
          userPreferences: {},
          emotionalState: {},
          attentionLevel: 'normal',
          responseQuality: [],
          // 高度な分析結果
          semanticContext: {},
          discourseMarkers: [],
          turnTaking: [],
          topicShifts: [],
          emotionalContinuity: []
        };
      }
      
      updateContext(userId, message, analysis, response) {
        const context = this.getContext(userId);
        
        // 基本情報の更新
        context.lastUserMessage = message;
        context.conversationLength++;
        context.lastResponseType = this.classifyResponseType(response);
        
        // トピックの追跡
        this.updateTopicContext(context, analysis);
        
        // 感情の追跡
        this.updateEmotionalContext(context, analysis);
        
        // 会話の流れの分析
        this.updateConversationFlow(context, message, response);
        
        // 注意レベルの推定
        context.attentionLevel = this.estimateAttentionLevel(context);
        
        // コンテキストの保存
        this.contexts.set(userId, context);
      }
      
      updateTopicContext(context, analysis) {
        if (analysis.topic && analysis.topic !== context.currentTopic) {
          // トピックの変更を記録
          if (context.currentTopic) {
            context.topicShifts.push({
              from: context.currentTopic,
              to: analysis.topic,
              timestamp: new Date().toISOString()
            });
          }
          
          context.currentTopic = analysis.topic;
          context.topicHistory.push({
            topic: analysis.topic,
            timestamp: new Date().toISOString(),
            confidence: analysis.confidence || 0
          });
          
          // トピック履歴を最新20件に制限
          if (context.topicHistory.length > 20) {
            context.topicHistory = context.topicHistory.slice(-20);
          }
        }
      }
      
      updateEmotionalContext(context, analysis) {
        if (analysis.emotions) {
          context.emotionalState = analysis.emotions;
          context.moodTrend.push({
            emotions: analysis.emotions,
            sentiment: analysis.sentiment,
            intensity: analysis.emotionLevel,
            timestamp: new Date().toISOString()
          });
          
          // 感情トレンドを最新50件に制限
          if (context.moodTrend.length > 50) {
            context.moodTrend = context.moodTrend.slice(-50);
          }
          
          // 感情の連続性を分析
          this.analyzeEmotionalContinuity(context);
        }
      }
      
      updateConversationFlow(context, message, response) {
        context.conversationFlow.push({
          userMessage: message,
          aiResponse: response,
          timestamp: new Date().toISOString(),
          turnType: this.classifyTurnType(message, response)
        });
        
        // 会話フローを最新100件に制限
        if (context.conversationFlow.length > 100) {
          context.conversationFlow = context.conversationFlow.slice(-100);
        }
      }
      
      classifyResponseType(response) {
        if (response.includes('検索')) return 'search';
        if (response.includes('時間') || response.includes('天気')) return 'information';
        if (response.includes('ありがとう') || response.includes('どういたしまして')) return 'gratitude';
        if (response.includes('？') || response.includes('教えて')) return 'question';
        return 'conversation';
      }
      
      classifyTurnType(message, response) {
        const messageType = this.getMessageType(message);
        const responseType = this.getMessageType(response);
        
        if (messageType === 'question' && responseType === 'answer') return 'qa';
        if (messageType === 'statement' && responseType === 'acknowledgment') return 'ack';
        if (messageType === 'greeting' && responseType === 'greeting') return 'greeting';
        return 'conversation';
      }
      
      getMessageType(text) {
        if (text.includes('？') || text.includes('?')) return 'question';
        if (text.includes('こんにちは') || text.includes('おはよう')) return 'greeting';
        if (text.includes('ありがとう')) return 'gratitude';
        if (text.includes('。') || text.includes('！')) return 'statement';
        return 'conversation';
      }
      
      analyzeEmotionalContinuity(context) {
        if (context.moodTrend.length < 2) return;
        
        const recentMoods = context.moodTrend.slice(-5);
        const emotionalContinuity = {
          stability: this.calculateEmotionalStability(recentMoods),
          trend: this.calculateEmotionalTrend(recentMoods),
          volatility: this.calculateEmotionalVolatility(recentMoods)
        };
        
        context.emotionalContinuity.push({
          ...emotionalContinuity,
          timestamp: new Date().toISOString()
        });
      }
      
      calculateEmotionalStability(moods) {
        if (moods.length < 2) return 1;
        
        const intensityChanges = [];
        for (let i = 1; i < moods.length; i++) {
          const change = Math.abs(moods[i].intensity - moods[i-1].intensity);
          intensityChanges.push(change);
        }
        
        const averageChange = intensityChanges.reduce((sum, change) => sum + change, 0) / intensityChanges.length;
        return Math.max(0, 1 - averageChange / 10);
      }
      
      calculateEmotionalTrend(moods) {
        if (moods.length < 2) return 'stable';
        
        const firstMood = moods[0].intensity;
        const lastMood = moods[moods.length - 1].intensity;
        const change = lastMood - firstMood;
        
        if (change > 1) return 'improving';
        if (change < -1) return 'declining';
        return 'stable';
      }
      
      calculateEmotionalVolatility(moods) {
        if (moods.length < 2) return 0;
        
        const intensities = moods.map(mood => mood.intensity);
        const mean = intensities.reduce((sum, intensity) => sum + intensity, 0) / intensities.length;
        const variance = intensities.reduce((sum, intensity) => sum + Math.pow(intensity - mean, 2), 0) / intensities.length;
        
        return Math.sqrt(variance);
      }
      
      estimateAttentionLevel(context) {
        const recentFlow = context.conversationFlow.slice(-10);
        const messageLengths = recentFlow.map(flow => flow.userMessage.length);
        const averageLength = messageLengths.reduce((sum, length) => sum + length, 0) / messageLengths.length;
        
        // メッセージの長さと感情の強度から注意レベルを推定
        if (averageLength > 50 && context.emotionalState.joy > 5) return 'high';
        if (averageLength < 10 && context.emotionalState.confusion > 5) return 'low';
        return 'normal';
      }
      
      getTimeOfDay() {
        const hour = new Date().getHours();
        if (hour >= 5 && hour < 12) return 'morning';
        if (hour >= 12 && hour < 17) return 'afternoon';
        if (hour >= 17 && hour < 21) return 'evening';
        return 'night';
      }
      
      getCurrentSeason() {
        const month = new Date().getMonth() + 1;
        if (month >= 3 && month <= 5) return 'spring';
        if (month >= 6 && month <= 8) return 'summer';
        if (month >= 9 && month <= 11) return 'autumn';
        return 'winter';
      }
      
      getContextSummary(userId = 'default') {
        const context = this.getContext(userId);
        return {
          currentTopic: context.currentTopic,
          userMood: context.userMood,
          conversationLength: context.conversationLength,
          attentionLevel: context.attentionLevel,
          emotionalTrend: context.emotionalContinuity.length > 0 ? 
            context.emotionalContinuity[context.emotionalContinuity.length - 1] : null,
          recentTopics: context.topicHistory.slice(-5),
          moodStability: context.emotionalContinuity.length > 0 ? 
            context.emotionalContinuity[context.emotionalContinuity.length - 1].stability : 1
        };
      }
    }
    
    // 高度なコンテキストマネージャーのインスタンス化
    const advancedContextManager = new AdvancedContextManager();
    
    // 従来のコンテキスト管理（後方互換性のため）
    let conversationContext = {
      currentTopic: '',
      userMood: 'neutral',
      conversationLength: 0,
      lastUserMessage: '',
      interests: [],
      timeOfDay: '',
      season: '',
      lastResponseType: ''
    };
    
    // ユーザー学習データ管理
    let userPreferences = {
      aiName: 'AIアシスタント', // AIの名前
      userName: '', // ユーザーの呼び方
      customCommands: {}, // カスタムコマンド
      personality: 'friendly', // AIの性格
      language: 'ja', // 使用言語
      responseStyle: 'normal', // 応答スタイル
      selectedCity: 'Tokyo', // 選択された都市（デフォルト: 東京）
      // 新しい学習機能

      learningMode: true,
      learningStyle: 'adaptive', // adaptive, pattern, contextual
      responseComplexity: 'medium', // simple, medium, complex
      autoLearn: true
    };
    
    // ローカルストレージから学習データを読み込み
    function loadUserPreferences() {
      try {
        const saved = localStorage.getItem('userPreferences');
        if (saved) {
          const parsed = JSON.parse(saved);
          userPreferences = { ...userPreferences, ...parsed };
          console.log('ユーザー設定を読み込みました:', userPreferences);
        }
      } catch (error) {
        console.error('ユーザー設定の読み込みエラー:', error);
      }
    }
    
    // ローカルストレージに学習データを保存
    function saveUserPreferences() {
      try {
        localStorage.setItem('userPreferences', JSON.stringify(userPreferences));
        console.log('ユーザー設定を保存しました:', userPreferences);
      } catch (error) {
        console.error('ユーザー設定の保存エラー:', error);
      }
    }
    
    // 都市データ
    const cityData = {
      'Tokyo': {
        name: '東京',
        latitude: 35.6762,
        longitude: 139.6503,
        timezone: 'Asia/Tokyo'
      },
      'Osaka': {
        name: '大阪',
        latitude: 34.6937,
        longitude: 135.5023,
        timezone: 'Asia/Tokyo'
      }
    };

    // ページ読み込み時にユーザー設定を読み込み
    loadUserPreferences();
    
    // AIのタイトルを更新
    updateAITitle();
    
    // 都市選択の初期化
    initializeCitySelector();
    
    // デバッグ用：コンテキスト情報を表示
    console.log('無料AI学習システムが起動しました！');
    console.log('コンテキスト管理:', conversationContext);
    
    // エラーハンドリングのテスト
    window.addEventListener('error', function(e) {
      console.error('グローバルエラー:', e.error);
    });
    
    window.addEventListener('unhandledrejection', function(e) {
      console.error('未処理のPromise拒否:', e.reason);
    });

    // 高度な感情分析とトピック抽出
    function analyzeUserMessage(message) {
      const analysis = {
        sentiment: 'neutral', // positive, negative, neutral
        topic: '',
        intent: '',
        urgency: 'low',
        formality: 'casual',
        keywords: [],
        emotionLevel: 0, // -5 to +5
        questionType: '', // specific, general, rhetorical
        contextClues: [],
        personalInfo: false, // 個人的な情報を含むか
        // 新しい高度分析フィールド
        emotions: {}, // 詳細な感情分析
        confidence: 0, // 分析の信頼度
        complexity: 'simple', // 文の複雑さ
        politeness: 'neutral', // 丁寧さレベル
        sarcasm: false, // 皮肉の検出
        emphasis: [] // 強調表現
      };
      
      // 高度な感情分析システム
      const emotionAnalyzer = new AdvancedEmotionAnalyzer();
      const emotionResult = emotionAnalyzer.analyze(message);
      
      // 感情分析結果を統合
      analysis.emotions = emotionResult.emotions;
      analysis.sentiment = emotionResult.primarySentiment;
      analysis.emotionLevel = emotionResult.intensity;
      analysis.confidence = emotionResult.confidence;
      
      // 従来の感情分析（フォールバック）
      const positiveWords = {
        strong: ['最高', '素晴らしい', '感動', '興奮', '愛してる', '大好き', '完璧', '驚き'],
        medium: ['嬉しい', '楽しい', '良い', '好き', '感謝', 'ありがとう', '幸せ', '期待', '希望', '満足'],
        mild: ['いい', 'よい', 'まあまあ', 'そこそこ', 'なんとか', 'おかげで']
      };
      
      const negativeWords = {
        strong: ['最悪', '絶望', '怒り', '憎い', '許せない', '苦しい', 'むかつく', '腹立つ'],
        medium: ['悲しい', '困った', '大変', '辛い', '嫌い', '怖い', '不安', '心配', 'イライラ', '落ち込み'],
        mild: ['微妙', 'ちょっと', '少し困る', 'やや不安', '軽く心配']
      };
      
      // 感情レベルの計算
      Object.entries(positiveWords).forEach(([level, words]) => {
        words.forEach(word => {
          if (message.includes(word)) {
            analysis.sentiment = 'positive';
            analysis.keywords.push(word);
            switch(level) {
              case 'strong': analysis.emotionLevel += 3; break;
              case 'medium': analysis.emotionLevel += 2; break;
              case 'mild': analysis.emotionLevel += 1; break;
            }
          }
        });
      });
      
      Object.entries(negativeWords).forEach(([level, words]) => {
        words.forEach(word => {
          if (message.includes(word)) {
            analysis.sentiment = 'negative';
            analysis.keywords.push(word);
            switch(level) {
              case 'strong': analysis.emotionLevel -= 3; break;
              case 'medium': analysis.emotionLevel -= 2; break;
              case 'mild': analysis.emotionLevel -= 1; break;
            }
          }
        });
      });
      
      // 感情レベルの正規化
      analysis.emotionLevel = Math.max(-5, Math.min(5, analysis.emotionLevel));
      
      // 拡張されたトピック分析
      const topics = {
        'work': ['仕事', '会社', 'オフィス', '会議', 'プロジェクト', '上司', '同僚', '残業', '転職', 'キャリア', '職場', '部署', '営業', '開発', '企画'],
        'hobby': ['趣味', '映画', '音楽', 'スポーツ', 'ゲーム', '読書', '料理', '旅行', '写真', 'アート', '釣り', 'ドライブ', 'ショッピング', 'カラオケ'],
        'family': ['家族', '子供', '親', '兄弟', '姉妹', '夫', '妻', '結婚', '育児', '家事', '両親', '祖父母', '孫', '息子', '娘'],
        'health': ['健康', '病気', '病院', '薬', '運動', 'ダイエット', '睡眠', 'ストレス', '疲労', '体調', '風邪', '頭痛', '腰痛', 'ジム'],
        'technology': ['パソコン', 'スマホ', 'アプリ', 'インターネット', 'AI', 'プログラミング', 'ゲーム', 'SNS', 'ソフト', 'ハード', 'クラウド'],
        'food': ['食べ物', '料理', 'レストラン', 'カフェ', 'お酒', '甘いもの', '和食', '洋食', '中華', 'ランチ', '夕食', '朝食', 'おやつ', 'デザート'],
        'weather': ['天気', '雨', '雪', '晴れ', '曇り', '暑い', '寒い', '春', '夏', '秋', '冬', '気温', '湿度', '台風', '梅雨'],
        'study': ['勉強', '学校', '大学', '試験', '宿題', '授業', '講義', '受験', '資格', '学習', 'テスト', '成績'],
        'relationship': ['友達', '恋人', '彼氏', '彼女', 'デート', '恋愛', '友情', '人間関係', '付き合い', '出会い'],
        'shopping': ['買い物', '服', '靴', 'バッグ', '化粧品', '家電', '家具', 'プレゼント', 'ギフト', 'セール'],
        'entertainment': ['テレビ', 'YouTube', 'Netflix', 'アニメ', 'ドラマ', 'バラエティ', 'ニュース', 'コンサート', 'ライブ'],
        'daily': ['日常', '毎日', '普段', '朝', '昼', '夜', '今日', '明日', '昨日', '週末', '平日']
      };
      
      Object.entries(topics).forEach(([key, words]) => {
        words.forEach(word => {
          if (message.includes(word)) {
            analysis.topic = key;
            analysis.keywords.push(word);
          }
        });
      });
      
      // 高度な意図分析
      // 質問の種類を詳細に分析
      if (message.includes('?') || message.includes('？')) {
        analysis.intent = 'question';
        if (message.includes('どう思う') || message.includes('どう感じる')) {
          analysis.questionType = 'opinion';
        } else if (message.includes('何') || message.includes('いつ') || message.includes('どこ') || message.includes('誰')) {
          analysis.questionType = 'specific';
        } else {
          analysis.questionType = 'general';
        }
      } else if (message.includes('教えて') || message.includes('どうして') || message.includes('なぜ') || message.includes('理由') || message.includes('原因')) {
        analysis.intent = 'question';
        analysis.questionType = 'explanation';
      } else if (message.includes('お願い') || message.includes('頼む') || message.includes('手伝って') || message.includes('助けて') || message.includes('やって') || message.includes('作成して') || message.includes('調べて')) {
        analysis.intent = 'request';
        if (message.includes('急いで') || message.includes('すぐに') || message.includes('至急')) {
          analysis.urgency = 'high';
        }
      } else if (message.includes('ありがとう') || message.includes('感謝') || message.includes('サンキュー') || message.includes('thanks') || message.includes('助かった')) {
        analysis.intent = 'gratitude';
      } else if (message.includes('こんにちは') || message.includes('おはよう') || message.includes('こんばんは') || message.includes('はじめまして') || message.includes('お疲れ')) {
        analysis.intent = 'greeting';
      } else if (message.includes('さようなら') || message.includes('バイバイ') || message.includes('またね') || message.includes('お疲れ様') || message.includes('失礼します')) {
        analysis.intent = 'farewell';
      } else if (message.includes('相談') || message.includes('悩み') || message.includes('困ってる') || message.includes('アドバイス')) {
        analysis.intent = 'consultation';
      } else if (message.includes('報告') || message.includes('知らせ') || message.includes('伝える') || message.includes('連絡')) {
        analysis.intent = 'information';
      }
      
      // 個人情報の検出
      if (message.includes('私は') || message.includes('僕は') || message.includes('俺は') || message.includes('自分は')) {
        analysis.personalInfo = true;
      }
      
      // 敬語の検出
      if (message.includes('です') || message.includes('ます') || message.includes('ございます') || message.includes('いたします')) {
        analysis.formality = 'formal';
      } else if (message.includes('だ') || message.includes('である') || message.includes('だよ') || message.includes('だね')) {
        analysis.formality = 'casual';
      }
      
      // 文脈手がかりの抽出
      if (message.includes('でも') || message.includes('しかし') || message.includes('ただ')) {
        analysis.contextClues.push('contrast');
      }
      if (message.includes('それで') || message.includes('だから') || message.includes('なので')) {
        analysis.contextClues.push('consequence');
      }
      if (message.includes('例えば') || message.includes('たとえば') || message.includes('具体的に')) {
        analysis.contextClues.push('example');
      }
      
      return analysis;
    }
    
    // ユーザー命令の学習・処理
    function processUserCommand(message) {
      const command = message.toLowerCase().trim();
      
      // AIの名前変更
      if (command.includes('名前') && (command.includes('呼んで') || command.includes('呼び方') || command.includes('名前を'))) {
        const nameMatch = message.match(/[「『]([^」』]+)[」』]/);
        if (nameMatch) {
          const newName = nameMatch[1];
          userPreferences.aiName = newName;
          saveUserPreferences();
          updateAITitle();
          return `ありがとうございます！これからは「${newName}」と呼ばせていただきます。`;
        } else {
          return 'AIの名前を変更したい場合は、「〇〇と呼んで」のように「」で囲んで教えてください。';
        }
      }
      
      // AIの名前を直接指定（新しい機能）
      if (message.includes('あなたは') && (message.includes('です') || message.includes('だ') || message.includes('だよ'))) {
        const nameMatch = message.match(/あなたは[「『]?([^」』\s]+)[」』]?です?/);
        if (nameMatch) {
          const newName = nameMatch[1];
          userPreferences.aiName = newName;
          saveUserPreferences();
          updateAITitle();
          return `ありがとうございます！これからは「${newName}」として活動させていただきます。`;
        }
      }
      
      // AIの名前を英語で指定
      if (message.includes('you are') || message.includes('you\'re')) {
        const nameMatch = message.match(/you\s+(?:are|re)\s+[「『]?([^」』\s]+)[」』]?/i);
        if (nameMatch) {
          const newName = nameMatch[1];
          userPreferences.aiName = newName;
          saveUserPreferences();
          updateAITitle();
          return `Thank you! From now on, I will be "${newName}".`;
        }
      }
      
      // ユーザーの呼び方変更
      if (command.includes('私') && (command.includes('呼んで') || command.includes('呼び方') || command.includes('名前を'))) {
        const nameMatch = message.match(/[「『]([^」』]+)[」』]/);
        if (nameMatch) {
          const newUserName = nameMatch[1];
          userPreferences.userName = newUserName;
          saveUserPreferences();
          return `ありがとうございます！これからは「${newUserName}」さんと呼びますね。`;
        } else {
          return 'ユーザーの呼び方を変更したい場合は、「私を〇〇と呼んで」のように「」で囲んで教えてください。';
        }
      }
      
      // ユーザー名を直接指定（新しい機能）
      if (message.includes('私の名前は') || message.includes('僕の名前は') || message.includes('俺の名前は')) {
        const nameMatch = message.match(/(?:私|僕|俺)の名前は[「『]?([^」』\s]+)[」』]?/);
        if (nameMatch) {
          const newUserName = nameMatch[1];
          userPreferences.userName = newUserName;
          saveUserPreferences();
          return `ありがとうございます！これからは「${newUserName}」さんと呼びますね。`;
        }
      }
      
      // 英語でのユーザー名指定
      if (message.includes('call me') || message.includes('my name is')) {
        let nameMatch;
        if (message.includes('call me')) {
          nameMatch = message.match(/call\s+me\s+[「『]?([^」』\s]+)[」』]?/i);
        } else if (message.includes('my name is')) {
          nameMatch = message.match(/my\s+name\s+is\s+[「『]?([^」』\s]+)[」』]?/i);
        }
        
        if (nameMatch) {
          const newUserName = nameMatch[1];
          userPreferences.userName = newUserName;
          saveUserPreferences();
          return `Thank you! From now on, I will call you "${newUserName}".`;
        }
      }
      
      // AIの性格変更
      if (command.includes('性格') && (command.includes('変えて') || command.includes('変更') || command.includes('設定'))) {
        if (command.includes('親しみやすい') || command.includes('フレンドリー')) {
          userPreferences.personality = 'friendly';
          saveUserPreferences();
          return '性格を親しみやすいフレンドリーな性格に変更しました！';
        } else if (command.includes('丁寧') || command.includes('フォーマル')) {
          userPreferences.personality = 'formal';
          saveUserPreferences();
          return '性格を丁寧でフォーマルな性格に変更しました！';
        } else if (command.includes('面白い') || command.includes('ユーモア')) {
          userPreferences.personality = 'humorous';
          saveUserPreferences();
          return '性格を面白くてユーモアのある性格に変更しました！';
        } else if (command.includes('専門的') || command.includes('プロフェッショナル')) {
          userPreferences.personality = 'professional';
          saveUserPreferences();
          return '性格を専門的でプロフェッショナルな性格に変更しました！';
        } else {
          return '利用可能な性格: 親しみやすい、丁寧、面白い、専門的。どの性格に変更しますか？';
        }
      }
      
      // 応答スタイル変更
      if (command.includes('応答') && (command.includes('変えて') || command.includes('変更') || command.includes('スタイル'))) {
        if (command.includes('簡潔') || command.includes('短く')) {
          userPreferences.responseStyle = 'concise';
          saveUserPreferences();
          return '応答スタイルを簡潔で短いスタイルに変更しました！';
        } else if (command.includes('詳しく') || command.includes('長く')) {
          userPreferences.responseStyle = 'detailed';
          saveUserPreferences();
          return '応答スタイルを詳しく長いスタイルに変更しました！';
        } else if (command.includes('絵文字') || command.includes('可愛く')) {
          userPreferences.responseStyle = 'cute';
          saveUserPreferences();
          return '応答スタイルを絵文字を使った可愛いスタイルに変更しました！';
        } else {
          return '利用可能な応答スタイル: 簡潔、詳しく、絵文字。どのスタイルに変更しますか？';
        }
      }
      
      // 言語変更
      if (command.includes('言語') && (command.includes('変えて') || command.includes('変更') || command.includes('設定'))) {
        if (command.includes('英語') || command.includes('english')) {
          userPreferences.language = 'en';
          saveUserPreferences();
          return '言語を英語に変更しました！I will respond in English from now on.';
        } else if (command.includes('日本語') || command.includes('japanese')) {
          userPreferences.language = 'ja';
          saveUserPreferences();
          return '言語を日本語に変更しました！';
        } else {
          return '利用可能な言語: 日本語、英語。どの言語に変更しますか？';
        }
      }
      
      // カスタムコマンドの学習（複数のパターンに対応）
      let commandLearned = false;
      
      // パターン1: 「覚えて」「コマンド」を含む場合
      if (command.includes('覚えて') && command.includes('コマンド')) {
        const commandMatch = message.match(/「([^」]+)」と言ったら「([^」]+)」と答えて/);
        if (commandMatch) {
          const trigger = commandMatch[1];
          const response = commandMatch[2];
          userPreferences.customCommands[trigger] = response;
          saveUserPreferences();
          commandLearned = true;
          console.log('カスタムコマンドを学習しました:', { trigger, response, allCommands: userPreferences.customCommands });
          return `覚えました！「${trigger}」と言ったら「${response}」と答えます。`;
        }
      }
      
      // パターン2: 「と言ったら」「と答えて」を含む場合
      if (!commandLearned && (message.includes('と言ったら') || message.includes('と言われたら'))) {
        const commandMatch = message.match(/「([^」]+)」?(?:と言ったら|と言われたら)「([^」]+)」?(?:と答えて|と返して|と返してください)/);
        if (commandMatch) {
          const trigger = commandMatch[1];
          const response = commandMatch[2];
          userPreferences.customCommands[trigger] = response;
          saveUserPreferences();
          commandLearned = true;
          return `覚えました！「${trigger}」と言われたら「${response}」と答えます。`;
        }
      }
      
      // パターン3: クォーテーションなしの場合
      if (!commandLearned && (message.includes('と言ったら') || message.includes('と言われたら'))) {
        const commandMatch = message.match(/([^「」]+)(?:と言ったら|と言われたら)([^「」]+)(?:と答えて|と返して|と返してください)/);
        if (commandMatch) {
          const trigger = commandMatch[1].trim();
          const response = commandMatch[2].trim();
          userPreferences.customCommands[trigger] = response;
          saveUserPreferences();
          commandLearned = true;
          return `覚えました！「${trigger}」と言われたら「${response}」と答えます。`;
        }
      }
      
      // パターン4: 英語での学習
      if (!commandLearned && (message.includes('if someone says') || message.includes('when someone says'))) {
        const commandMatch = message.match(/(?:if someone says|when someone says)\s*["']([^"']+)["']\s*(?:please reply|reply|respond)\s*["']([^"']+)["']/i);
        if (commandMatch) {
          const trigger = commandMatch[1];
          const response = commandMatch[2];
          userPreferences.customCommands[trigger] = response;
          saveUserPreferences();
          commandLearned = true;
          return `I learned! When someone says "${trigger}", I will reply "${response}".`;
        }
      }
      
      // 学習できなかった場合の案内
      if (!commandLearned && (message.includes('と言ったら') || message.includes('と言われたら') || message.includes('if someone says'))) {
        return 'カスタムコマンドを学習するには、以下のような形式で教えてください：\n' +
               '• 「〇〇と言ったら△△と答えて」\n' +
               '• 〇〇と言われたら△△と返してください\n' +
               '• If someone says "hello", please reply "hi"\n' +
               '• 「気温教えて」と言われたら気温情報を表示する';
      }
      
      // カスタムコマンドの実行
      if (userPreferences.customCommands[message]) {
        return userPreferences.customCommands[message];
      }
      
      // 部分一致でのカスタムコマンド実行（より柔軟な検索）
      for (const [trigger, response] of Object.entries(userPreferences.customCommands)) {
        if (message.includes(trigger) || trigger.includes(message)) {
          return response;
        }
      }
      
      // 設定の確認
      if (command.includes('設定') && (command.includes('確認') || command.includes('見せて') || command.includes('教えて'))) {
        return `現在の設定:\n` +
               `• AIの名前: ${userPreferences.aiName}\n` +
               `• ユーザーの呼び方: ${userPreferences.userName || '設定なし'}\n` +
               `• 性格: ${getPersonalityName(userPreferences.personality)}\n` +
               `• 応答スタイル: ${getResponseStyleName(userPreferences.responseStyle)}\n` +
               `• 言語: ${getLanguageName(userPreferences.language)}\n` +
               `• 選択都市: ${cityData[userPreferences.selectedCity].name}\n` +
               `• カスタムコマンド: ${Object.keys(userPreferences.customCommands).length}個`;
      }
      
      // 都市変更
      if (command.includes('都市') && (command.includes('変更') || command.includes('変えて') || command.includes('切り替え'))) {
        if (command.includes('大阪') || command.includes('osaka')) {
          userPreferences.selectedCity = 'Osaka';
          saveUserPreferences();
          updateCitySelector();
          return '都市を大阪に変更しました！';
        } else if (command.includes('東京') || command.includes('tokyo')) {
          userPreferences.selectedCity = 'Tokyo';
          saveUserPreferences();
          updateCitySelector();
          return '都市を東京に変更しました！';
        } else {
          return '利用可能な都市: 東京、大阪。どの都市に変更しますか？';
        }
      }
      
      // 設定のリセット
      if (command.includes('設定') && (command.includes('リセット') || command.includes('初期化') || command.includes('元に戻す'))) {
        userPreferences = {
          aiName: 'AIアシスタント',
          userName: '',
          customCommands: {},
          personality: 'friendly',
          language: 'ja',
          responseStyle: 'normal',
          selectedCity: 'Tokyo'
        };
        saveUserPreferences();
        updateAITitle();
        updateCitySelector();
        return '設定を初期状態にリセットしました！';
      }
      
      return null; // 命令でない場合はnullを返す
    }
    
    // 性格名を日本語で取得
    function getPersonalityName(personality) {
      const names = {
        'friendly': '親しみやすい',
        'formal': '丁寧',
        'humorous': '面白い',
        'professional': '専門的'
      };
      return names[personality] || personality;
    }
    
    // 応答スタイル名を日本語で取得
    function getResponseStyleName(style) {
      const names = {
        'concise': '簡潔',
        'detailed': '詳しく',
        'cute': '絵文字',
        'normal': '通常'
      };
      return names[style] || style;
    }
    
    // 言語名を日本語で取得
    function getLanguageName(language) {
      const names = {
        'ja': '日本語',
        'en': '英語'
      };
      return names[language] || language;
    }
    
    // AIのタイトルを更新
    function updateAITitle() {
      const titleElement = document.querySelector('.header h1');
      if (titleElement) {
        titleElement.textContent = userPreferences.aiName;
      }
    }
    
    // 都市選択の初期化
    function initializeCitySelector() {
      const citySelect = document.getElementById('city-select');
      if (citySelect) {
        // 保存された都市を選択
        citySelect.value = userPreferences.selectedCity;
        
        // 都市変更時のイベントリスナー
        citySelect.addEventListener('change', function() {
          const selectedCity = this.value;
          userPreferences.selectedCity = selectedCity;
          saveUserPreferences();
          console.log(`都市を${cityData[selectedCity].name}に変更しました`);
        });
      }
    }
    
    // 都市選択の更新
    function updateCitySelector() {
      const citySelect = document.getElementById('city-select');
      if (citySelect) {
        citySelect.value = userPreferences.selectedCity;
      }
    }

    // コンテキストの更新
    function updateConversationContext(analysis) {
      conversationContext.conversationLength++;
      conversationContext.lastUserMessage = analysis.keywords.join(', ');
      
      if (analysis.topic) {
        conversationContext.currentTopic = analysis.topic;
      }
      
      if (analysis.sentiment !== 'neutral') {
        conversationContext.userMood = analysis.sentiment;
      }
      
      // 時間と季節の更新
      const now = new Date();
      const hour = now.getHours();
      const month = now.getMonth() + 1;
      
      if (hour < 12) conversationContext.timeOfDay = 'morning';
      else if (hour < 18) conversationContext.timeOfDay = 'afternoon';
      else conversationContext.timeOfDay = 'evening';
      
      if (month >= 3 && month <= 5) conversationContext.season = 'spring';
      else if (month >= 6 && month <= 8) conversationContext.season = 'summer';
      else if (month >= 9 && month <= 11) conversationContext.season = 'autumn';
      else conversationContext.season = 'winter';
      
      // 興味の学習
      if (analysis.topic && !conversationContext.interests.includes(analysis.topic)) {
        conversationContext.interests.push(analysis.topic);
      }
    }

        // 高度なコンテキストに基づく応答パターン選択
    function selectResponsePattern(analysis) {
      try {
        console.log('分析結果:', analysis);
        
        // 相談に対する特別な応答
        if (analysis.intent === 'consultation') {
          return getConsultationResponse(analysis);
        }
        
        // 情報提供に対する応答
        if (analysis.intent === 'information') {
          return getInformationResponse(analysis);
        }
        
        // 感情レベルに基づく応答
        if (analysis.emotionLevel >= 3) {
          return getHighPositiveResponse(analysis);
        } else if (analysis.emotionLevel <= -3) {
          return getHighNegativeResponse(analysis);
        } else if (analysis.sentiment === 'positive') {
          return getPositiveResponse();
        } else if (analysis.sentiment === 'negative') {
          return getSupportiveResponse();
        }
        
        // 質問タイプに基づく詳細応答
        if (analysis.intent === 'question') {
          return getQuestionResponseByType(analysis);
        }
        
        // 現在のトピックとの継続性
        if (conversationContext.currentTopic && analysis.topic === conversationContext.currentTopic) {
          return getTopicContinuationResponse(analysis);
        }
        
        // 新しいトピックへの応答
        if (analysis.topic) {
          return getTopicSpecificResponse(analysis.topic);
        }
        
        // 意図に基づく応答
        if (analysis.intent === 'request') {
          return getRequestResponse();
        } else if (analysis.intent === 'gratitude') {
          return getGratitudeResponse();
        } else if (analysis.intent === 'greeting') {
          return getGreetingResponse();
        } else if (analysis.intent === 'farewell') {
          return getFarewellResponse();
        }
        
        // 個人的な情報を含む場合の応答
        if (analysis.personalInfo) {
          return getPersonalResponse(analysis);
        }
        
        // 時間・季節に基づく応答
        return getTimeBasedResponse();
      } catch (error) {
        console.error('応答パターン選択エラー:', error);
        return 'こんにちは！何かお手伝いできることはありますか？';
      }
    }

    // トピック別の応答
    function getTopicSpecificResponse(topic) {
      const topicResponses = {
        'work': [
          '仕事についてお聞かせください。どんなことがありましたか？',
          'お仕事お疲れ様です。今日はどんな一日でしたか？',
          '仕事の話、とても興味深いですね。詳しく教えてください。'
        ],
        'hobby': [
          '趣味の話、とても楽しいですね！どんなことが好きですか？',
          '趣味があると人生が豊かになりますよね。何か新しいことに挑戦していますか？',
          '趣味の話を聞くのが大好きです。もっと教えてください！'
        ],
        'family': [
          '家族の話、とても温かみがありますね。大切な存在ですよね。',
          '家族との時間、とても貴重ですね。どんなことがありましたか？',
          '家族のことを大切に思う気持ち、素晴らしいです。'
        ],
        'health': [
          '健康は何より大切ですね。体調管理はしっかりされていますか？',
          '健康について考えるのはとても重要です。何か気になることはありますか？',
          '健康な体でいることが、幸せの基本ですね。'
        ]
      };
      
      const responses = topicResponses[topic] || ['その話題、とても興味深いですね。'];
      return responses[Math.floor(Math.random() * responses.length)];
    }

    // 主要な感情を取得
    function getDominantEmotion(emotions) {
      let maxEmotion = 'neutral';
      let maxValue = 0;
      
      for (const [emotion, value] of Object.entries(emotions)) {
        if (value > maxValue) {
          maxValue = value;
          maxEmotion = emotion;
        }
      }
      
      return maxEmotion;
    }
    
    // 感情別の応答
    function getPositiveResponse() {
      const responses = [
        'とても良いですね！その気持ち、大切にしてください。',
        '素晴らしいです！私も嬉しくなります。',
        'とても良いことがあったようですね。詳しく聞かせてください。',
        'その前向きな気持ち、とても素敵です！',
        '素晴らしいニュースですね！おめでとうございます！',
        'その喜びの気持ち、とても伝わってきます。',
        '良いことがあったようで、私も嬉しいです。',
        'その前向きなエネルギー、素晴らしいですね。',
        'とても良い一日になりそうですね！',
        'その気持ち、周りの人にも伝染しそうですね。'
      ];
      return responses[Math.floor(Math.random() * responses.length)];
    }

    function getSupportiveResponse() {
      const responses = [
        '大丈夫ですか？何かお手伝いできることがあれば教えてください。',
        '辛いことがあったようですね。話を聞かせてください。',
        '一人で抱え込まないでください。いつでも話を聞きますよ。',
        'その気持ち、よく分かります。一緒に考えましょう。',
        '大変でしたね。ゆっくり休んでください。',
        '辛い時は無理をしないでください。',
        'その気持ち、とても分かります。',
        '一人じゃありませんよ。いつでもサポートします。',
        '大丈夫、きっと乗り越えられます。',
        '辛い時こそ、自分を大切にしてくださいね。'
      ];
      return responses[Math.floor(Math.random() * responses.length)];
    }

    // 時間・季節に基づく応答
    function getTimeBasedResponse() {
      const timeResponses = {
        'morning': [
          'おはようございます！今日も一日頑張りましょう。',
          'おはよう！今日はどんな一日にしましょうか？',
          'おはようございます。今日も素晴らしい一日になりますように。',
          'おはよう！朝から元気いっぱいですね。',
          'おはようございます。今日も新しい発見がありますように。'
        ],
        'afternoon': [
          '午後も頑張りましょう！',
          '午後の時間、いかがお過ごしですか？',
          '午後も充実した時間にしましょう。',
          '午後の時間、何か楽しいことはありますか？',
          '午後も元気に過ごしましょう！'
        ],
        'evening': [
          'お疲れ様でした。今日も一日お疲れさまでした。',
          '一日お疲れ様でした。ゆっくり休んでくださいね。',
          'お疲れ様です。今日はどんな一日でしたか？',
          '一日の終わり、ゆっくりリラックスしましょう。',
          'お疲れ様でした。明日も良い一日になりますように。'
        ]
      };
      
      const seasonResponses = {
        'spring': [
          '春らしい気持ちの良い一日ですね。',
          '春の風が心地よい季節ですね。',
          '桜の季節、とても美しいですね。',
          '春の陽気、過ごしやすいですね。',
          '春の訪れを感じる季節ですね。'
        ],
        'summer': [
          '夏の暑さ、体調管理に気をつけましょう。',
          '夏の日差し、とても強いですね。',
          '夏の風物詩、楽しんでいますか？',
          '夏の暑さ、水分補給を忘れずに。',
          '夏の季節、何か楽しい予定はありますか？'
        ],
        'autumn': [
          '秋の涼しさ、過ごしやすい季節ですね。',
          '秋の紅葉、とても美しいですね。',
          '秋の風、心地よいですね。',
          '秋の季節、何か楽しみはありますか？',
          '秋の夜長、ゆっくり過ごしましょう。'
        ],
        'winter': [
          '冬の寒さ、温かくしてお過ごしください。',
          '冬の季節、温かい飲み物が美味しいですね。',
          '冬の寒さ、体調管理に気をつけましょう。',
          '冬の季節、何か楽しみはありますか？',
          '冬の寒さ、春が待ち遠しいですね。'
        ]
      };
      
      // ランダムに時間と季節の応答を選択
      const timeResponse = timeResponses[conversationContext.timeOfDay] || timeResponses['afternoon'];
      const seasonResponse = seasonResponses[conversationContext.season] || seasonResponses['summer'];
      
      return timeResponse[Math.floor(Math.random() * timeResponse.length)] + ' ' + 
             seasonResponse[Math.floor(Math.random() * seasonResponse.length)];
    }

    function generateConversationPatterns() {
      const greetings = [
        // 基本挨拶
        "こんにちは", "やあ", "お元気ですか", "こんばんは", "おはよう", "はじめまして",
        "久しぶり", "お疲れ様", "よろしく", "どうも", "やっほー", "おっす",
        "こんにちは！", "やあ！", "お元気ですか？", "こんばんは！", "おはよう！", "はじめまして！",
        "久しぶり！", "お疲れ様！", "よろしく！", "どうも！", "やっほー！", "おっす！",
        "こんにちは〜", "やあ〜", "お元気ですか〜", "こんばんは〜", "おはよう〜", "はじめまして〜",
        "久しぶり〜", "お疲れ様〜", "よろしく〜", "どうも〜", "やっほー〜", "おっす〜",
        
        // 時間帯別挨拶
        "おはようございます", "おはようございます！", "おはようございます〜",
        "こんにちはございます", "こんにちはございます！", "こんにちはございます〜",
        "こんばんはございます", "こんばんはございます！", "こんばんはございます〜",
        "おやすみなさい", "おやすみなさい！", "おやすみなさい〜",
        
        // 丁寧な挨拶
        "いらっしゃいませ", "いらっしゃいませ！", "いらっしゃいませ〜",
        "お世話になっております", "お世話になっております！", "お世話になっております〜",
        "いつもお世話になっております", "いつもお世話になっております！", "いつもお世話になっております〜",
        
        // カジュアルな挨拶
        "よっ", "よっ！", "よっ〜", "やっほー", "やっほー！", "やっほー〜",
        "おっす", "おっす！", "おっす〜", "よろしく", "よろしく！", "よろしく〜",
        
        // 季節の挨拶
        "春ですね", "春ですね！", "春ですね〜", "夏ですね", "夏ですね！", "夏ですね〜",
        "秋ですね", "秋ですね！", "秋ですね〜", "冬ですね", "冬ですね！", "冬ですね〜",
        
        // 天気の挨拶
        "いい天気ですね", "いい天気ですね！", "いい天気ですね〜",
        "雨ですね", "雨ですね！", "雨ですね〜", "雪ですね", "雪ですね！", "雪ですね〜",
        
        // 時間の挨拶
        "早いですね", "早いですね！", "早いですね〜", "遅いですね", "遅いですね！", "遅いですね〜",
        "お疲れ様です", "お疲れ様です！", "お疲れ様です〜", "お疲れ様でした", "お疲れ様でした！", "お疲れ様でした〜"
      ];

      const topics = [
        // 日常生活
        "今日の天気", "最近のニュース", "お気に入りの映画", "好きな音楽", "趣味", "仕事",
        "学校", "家族", "友達", "旅行", "食べ物", "スポーツ", "読書", "ゲーム",
        "映画", "テレビ", "インターネット", "SNS", "買い物", "料理", "掃除", "洗濯",
        "散歩", "ドライブ", "カフェ", "レストラン", "公園", "海", "山", "街",
        "季節", "花", "動物", "車", "電車", "バス", "飛行機", "船", "自転車",
        "スマートフォン", "パソコン", "テレビ", "エアコン", "洗濯機", "冷蔵庫",
        
        // 仕事・学習
        "会議", "プレゼンテーション", "レポート", "テスト", "試験", "宿題", "課題",
        "プロジェクト", "企画", "アイデア", "計画", "目標", "夢", "将来", "キャリア",
        "スキル", "資格", "勉強", "学習", "研究", "調査", "分析", "データ",
        "報告書", "提案書", "契約書", "マニュアル", "ガイド", "説明書", "手順書",
        
        // 趣味・娯楽
        "アニメ", "漫画", "小説", "詩", "絵画", "写真", "カメラ", "楽器", "歌",
        "ダンス", "ヨガ", "ピラティス", "ジム", "ランニング", "ウォーキング", "水泳",
        "テニス", "サッカー", "野球", "バスケットボール", "ゴルフ", "スキー", "スノーボード",
        "釣り", "キャンプ", "登山", "ハイキング", "サイクリング", "スケート", "ボウリング",
        
        // 食べ物・飲み物
        "日本料理", "中華料理", "イタリアン", "フレンチ", "エスニック", "和菓子", "洋菓子",
        "パン", "パスタ", "ピザ", "寿司", "ラーメン", "うどん", "そば", "カレー",
        "コーヒー", "紅茶", "緑茶", "ジュース", "ワイン", "ビール", "日本酒",
        "焼肉", "しゃぶしゃぶ", "天ぷら", "とんかつ", "オムライス", "ハンバーガー",
        
        // 場所・観光
        "東京", "大阪", "京都", "横浜", "名古屋", "札幌", "福岡", "神戸", "仙台",
        "沖縄", "北海道", "東北", "関東", "中部", "関西", "中国", "四国", "九州",
        "浅草寺", "清水寺", "金閣寺", "銀閣寺", "東大寺", "法隆寺", "厳島神社",
        "富士山", "箱根", "日光", "軽井沢", "伊豆", "熱海", "湯河原", "由布院",
        
        // 季節・自然
        "桜", "梅", "桃", "藤", "アジサイ", "ひまわり", "コスモス", "菊", "紅葉",
        "春風", "夏空", "秋空", "冬空", "朝日", "夕日", "星空", "月", "雲",
        "雨", "雪", "雷", "虹", "霧", "霜", "露", "風", "波", "潮",
        
        // 感情・心理
        "喜び", "悲しみ", "怒り", "驚き", "恐れ", "期待", "希望", "不安", "緊張",
        "リラックス", "興奮", "落ち込み", "やる気", "やる気喪失", "自信", "自信喪失",
        "感謝", "後悔", "反省", "成長", "変化", "進歩", "停滞", "退歩",
        
        // 人間関係
        "恋愛", "友情", "愛情", "信頼", "尊敬", "憧れ", "嫉妬", "羨望", "同情",
        "共感", "理解", "誤解", "和解", "仲直り", "別れ", "出会い", "再会",
        "結婚", "離婚", "出産", "育児", "子育て", "介護", "看護", "看護",
        
        // テクノロジー
        "AI", "機械学習", "ディープラーニング", "ブロックチェーン", "IoT", "5G", "6G",
        "VR", "AR", "MR", "メタバース", "NFT", "暗号通貨", "ビットコイン", "イーサリアム",
        "クラウド", "セキュリティ", "プライバシー", "データ保護", "サイバー攻撃",
        
        // 社会・文化
        "政治", "経済", "社会", "文化", "歴史", "伝統", "現代", "未来", "過去",
        "グローバル化", "多様性", "インクルージョン", "サステナビリティ", "環境問題",
        "貧困", "格差", "差別", "人権", "自由", "平等", "正義", "平和"
      ];

      const responses = [
        // 肯定的・共感的
        "とても興味深いですね", "それは素晴らしいです", "なるほど、面白いです", "確かにそうですね",
        "私も同じように思います", "それは良いアイデアですね", "勉強になります", "参考になります",
        "素敵ですね", "楽しいですね", "面白そうですね", "やってみたいですね", "頑張ってください",
        "応援しています", "期待しています", "楽しみですね", "良かったですね", "お疲れ様でした",
        "おめでとうございます", "お気の毒です", "大変でしたね", "心配ですね", "安心しました",
        "驚きました", "びっくりしました", "感動しました", "嬉しいです", "悲しいです", "怒っています",
        "困っています", "悩んでいます", "迷っています", "決めました", "変わりました", "進歩しました",
        
        // より詳細な反応
        "本当に素晴らしいですね", "それは素晴らしいアイデアです", "とても良い考えですね",
        "私も同じような経験があります", "それは素晴らしい選択ですね", "とても良い判断だと思います",
        "それは素晴らしい成果ですね", "とても良い結果だと思います", "それは素晴らしい発見ですね",
        "とても良い機会ですね", "それは素晴らしいチャンスですね", "とても良いタイミングですね",
        "それは素晴らしい努力ですね", "とても良い頑張りですね", "それは素晴らしい成長ですね",
        "とても良い変化ですね", "それは素晴らしい進歩ですね", "とても良い発展ですね",
        
        // 質問・興味
        "詳しく教えてください", "もっと詳しく聞かせてください", "それはどういうことですか",
        "どのような感じでしたか", "どんな風に思いましたか", "どのような印象でしたか",
        "それはいつ頃のことですか", "どこで体験されたのですか", "誰と一緒でしたか",
        "どのような状況でしたか", "どんな気持ちでしたか", "どのような影響がありましたか",
        
        // 励まし・応援
        "きっと大丈夫です", "必ずうまくいきます", "あなたならできます",
        "頑張ってください", "応援しています", "期待しています", "信じています",
        "一歩ずつ進みましょう", "焦らずに頑張りましょう", "無理をしないでください",
        "休憩も大切です", "リフレッシュしてください", "リラックスしてください",
        
        // 共感・理解
        "それは大変でしたね", "お疲れ様でした", "よく頑張りましたね",
        "それは辛かったでしょう", "それは苦しかったでしょう", "それは悲しかったでしょう",
        "それは嬉しかったでしょう", "それは楽しかったでしょう", "それは面白かったでしょう",
        "それは驚きでしたね", "それはびっくりでしたね", "それは感動的でしたね",
        
        // 提案・アドバイス
        "試してみてはいかがですか", "やってみることをお勧めします", "一度挑戦してみてください",
        "時間をかけて考えてみてください", "ゆっくり進めてみてください", "焦らずに取り組んでください",
        "他の方法も考えてみてください", "別の角度から見てみてください", "新しい視点で考えてみてください",
        
        // 評価・感想
        "それは素晴らしいですね", "とても良いと思います", "素敵だと思います",
        "それは興味深いですね", "面白そうですね", "やってみたいですね",
        "それは良いアイデアですね", "とても良い考えだと思います", "素晴らしい発想ですね",
        "それは良い経験ですね", "とても良い思い出になりそうですね", "素敵な時間になりそうですね"
      ];

      const emotions = [
        // 笑顔・喜び
        "😊", "😄", "😃", "😀", "😁", "😆", "😅", "😂", "🤣", "😇",
        "🙂", "🙃", "😉", "😌", "😍", "🥰", "😘", "😗", "😙", "😚",
        "😋", "😛", "😝", "😜", "🤪", "🤨", "🧐", "🤓", "😎", "🤩",
        "🥳", "😏", "😒", "😞", "😔", "😟", "😕", "🙁", "☹️", "😣",
        "😖", "😫", "😩", "🥺", "😢", "😭", "😤", "😠", "😡", "🤬",
        "🤯", "😳", "🥵", "🥶", "😱", "😨", "😰", "😥", "😓", "🤗",
        "🤔", "🤭", "🤫", "🤥", "😶", "😐", "😑", "😯", "😦", "😧",
        
        // 祝福・成功
        "✨", "🎉", "💪", "🌟", "💖", "🎵", "🌈", "🍀", "🎊", "🎈",
        "🎁", "🎂", "🎃", "🎄", "🎋", "🎍", "🎎", "🎏", "🎐", "🎑",
        "🎀", "🎁", "🎂", "🎃", "🎄", "🎋", "🎍", "🎎", "🎏", "🎐",
        
        // 動物・自然
        "🐶", "🐱", "🐭", "🐹", "🐰", "🦊", "🐻", "🐼", "🐨", "🐯",
        "🦁", "🐮", "🐷", "🐸", "🐵", "🐔", "🐧", "🐦", "🐤", "🐣",
        "🦆", "🦅", "🦉", "🦇", "🐺", "🐗", "🐴", "🦄", "🐝", "🐛",
        "🦋", "🐌", "🐞", "🐜", "🦟", "🦗", "🕷️", "🕸️", "🦂", "🐢",
        "🐍", "🦎", "🦖", "🦕", "🐙", "🦑", "🦐", "🦞", "🦀", "🐡",
        "🐠", "🐟", "🐬", "🐳", "🐋", "🦈", "🐊", "🐅", "🐆", "🦓",
        
        // 食べ物・飲み物
        "🍎", "🍐", "🍊", "🍋", "🍌", "🍉", "🍇", "🍓", "🫐", "🍈",
        "🍒", "🍑", "🥭", "🍍", "🥥", "🥝", "🍅", "🥑", "🥦", "🥬",
        "🥒", "🌶️", "🫑", "🌽", "🥕", "🫒", "🧄", "🧅", "🥔", "🍠",
        "🥐", "🥯", "🍞", "🥖", "🥨", "🧀", "🥚", "🍳", "🧈", "🥞",
        "🧇", "🥓", "🥩", "🍗", "🍖", "🦴", "🌭", "🍔", "🍟", "🍕",
        
        // 活動・スポーツ
        "⚽", "🏀", "🏈", "⚾", "🥎", "🎾", "🏐", "🏉", "🥏", "🎱",
        "🪀", "🏓", "🏸", "🏒", "🏑", "🥍", "🏏", "🥅", "⛳", "🪁",
        "🏹", "🎣", "🤿", "🥊", "🥋", "🎽", "🛹", "🛷️", "⛸️", "🥌",
        "🎿", "⛷️", "🏂", "🪂", "🏋️‍♀️", "🏋️‍♂️", "🤼‍♀️", "🤼‍♂️", "🤸‍♀️", "🤸‍♂️",
        "⛹️‍♀️", "⛹️‍♂️", "🤺", "🤾‍♀️", "🤾‍♂️", "🏊‍♀️", "🏊‍♂️", "🚣‍♀️", "🚣‍♂️", "🧘‍♀️",
        
        // 乗り物・交通
        "🚗", "🚕", "🚙", "🚌", "🚎", "🏎️", "🚓", "🚑", "🚒", "🚐",
        "🚚", "🚛", "🚜", "🛴️", "🚲", "🛵", "🏍️", "🚨", "🚔", "🚍",
        "🚘", "🚖", "🚡", "🚠", "🚟", "🚃", "🚋", "🚞", "🚝", "🚄",
        "🚅", "🚈", "🚂", "🚆", "🚇", "🚊", "🚉", "✈️", "🛫", "🛬",
        "🛩️", "💺", "🛰️", "🚀", "🛸️", "🚁", "🛻", "🚜", "🏎️", "🏍️",
        
        // 場所・建物
        "🏠", "🏡", "🏘️", "🏚️", "🏗️", "🏭", "🏢", "🏬", "🏣", "🏤",
        "🏥", "🏦", "🏨", "🏪", "🏫", "🏩", "💒", "⛪", "🕌", "🕍",
        "🛕", "⛩️", "🕋", "⛲", "⛺", "🏕️", "🏖️", "🏜️", "🏝️", "🏔️",
        "⛰️", "🌋", "🗻", "🏕️", "🏖️", "🏜️", "🏝️", "🏔️", "⛰️", "🌋",
        
        // 天気・自然現象
        "☀️", "🌤️", "⛅", "🌥️", "☁️", "🌦️", "🌧️", "⛈️", "🌩️", "🌨️",
        "💧", "💦", "💨", "🌪️", "🌈", "☂️", "☔", "⚡", "❄️", "🔥",
        "💥", "💫", "⭐", "🌟", "✨", "⚡", "💥", "💫", "⭐", "🌟",
        
        // 時間・時計
        "🕐", "🕑", "🕒", "🕓", "🕔", "🕕", "🕖", "🕗", "🕘", "🕙",
        "🕚", "🕛", "🕜", "🕝", "🕞", "🕟", "🕠", "🕡", "🕢", "🕣",
        "🕤", "🕥", "🕦", "🕧", "⌚", "⏰", "⏱️", "⏲️", "🕰️", "⌛",
        
        // 記号・装飾
        "💯", "💢", "💮", "💭", "💬", "💤", "💫", "💥", "💦", "💨",
        "💧", "💩", "💪", "💋", "💌", "💘", "💝", "💖", "💗", "💓",
        "💕", "💞", "💟", "❣️", "💔", "❤️", "🩷", "🧡", "💛", "💚",
        "💙", "🩵", "💜", "🖤", "🩶", "🤍", "🤎", "💔", "❣️", "💕"
      ];

      const connectors = [
        // 順接・追加
        "そして", "また", "さらに", "それに", "加えて", "その上", "なお", "ちなみに",
        "ところで", "さて", "では", "それでは", "それなら", "そうすると", "その結果",
        "そのため", "その理由で", "なぜなら", "というのは", "つまり", "要するに",
        "簡単に言えば", "言い換えれば", "例えば", "特に", "特に", "特に", "特に",
        "一方で", "反対に", "逆に", "しかし", "でも", "けれども", "ただし", "もっとも",
        "確かに", "確かに", "確かに", "確かに", "確かに", "確かに", "確かに", "確かに",
        
        // より詳細な接続詞
        "さらに詳しく言えば", "より具体的には", "具体的には", "詳細には", "詳しくは",
        "言い換えると", "別の言い方をすれば", "つまり", "すなわち", "要するに",
        "簡単に言うと", "一言で言えば", "端的に言えば", "率直に言えば", "正直に言えば",
        "実は", "実際には", "本当は", "実際のところ", "現実には", "実際問題として",
        "理論的には", "理想的には", "現実的には", "実際的には", "実用的には",
        "個人的には", "個人的な意見ですが", "私見ですが", "私の考えでは", "私としては",
        "一般的には", "通常は", "普通は", "大抵は", "大概は", "大方は", "概ね",
        "比較的", "比較的に", "相対的に", "相対的には", "絶対的には", "絶対的に",
        "基本的には", "基本的に", "根本的には", "根本的に", "本質的には", "本質的に",
        "表面的には", "表面的に", "形式的には", "形式的に", "実質的には", "実質的に",
        "理論的には", "理論的に", "実践的には", "実践的に", "実際的には", "実際的に",
        "理想的には", "理想的に", "現実的には", "現実的に", "実用的には", "実用的に",
        "個人的には", "個人的に", "一般的には", "一般的に", "通常は", "通常に",
        "比較的には", "比較的に", "相対的には", "相対的に", "絶対的には", "絶対的に",
        "基本的には", "基本的に", "根本的には", "根本的に", "本質的には", "本質的に",
        "表面的には", "表面的に", "形式的には", "形式的に", "実質的には", "実質的に"
      ];

      const endings = [
        // 基本終了語
        "です", "ですね", "ですよ", "でしょう", "かもしれません", "と思います", "感じです",
        "です！", "ですね！", "ですよ！", "でしょう！", "かもしれません！", "と思います！", "感じです！",
        "です〜", "ですね〜", "ですよ〜", "でしょう〜", "かもしれません〜", "と思います〜", "感じです〜",
        "です。", "ですね。", "ですよ。", "でしょう。", "かもしれません。", "と思います。", "感じです。",
        "です...", "ですね...", "ですよ...", "でしょう...", "かもしれません...", "と思います...", "感じです...",
        
        // より詳細な終了語
        "そう思います", "そう感じます", "そう考えます", "そう思われます", "そう感じられます",
        "そう考えられます", "そう思われている", "そう感じられている", "そう考えられている",
        "そう思われているようです", "そう感じられているようです", "そう考えられているようです",
        "そう思われているかもしれません", "そう感じられているかもしれません", "そう考えられているかもしれません",
        "そう思われているでしょう", "そう感じられているでしょう", "そう考えられているでしょう",
        "そう思われていると思います", "そう感じられていると思います", "そう考えられていると思います",
        "そう思われている感じです", "そう感じられている感じです", "そう考えられている感じです",
        "そう思われているような気がします", "そう感じられているような気がします", "そう考えられているような気がします",
        "そう思われているような感じがします", "そう感じられているような感じがします", "そう考えられているような感じがします",
        "そう思われているような印象を受けます", "そう感じられているような印象を受けます", "そう考えられているような印象を受けます",
        "そう思われているような印象があります", "そう感じられているような印象があります", "そう考えられているような印象があります"
      ];

      const patterns = [];
      let patternCount = 0;

      // 基本パターン（約10,000パターン）
      for (let g = 0; g < greetings.length && patternCount < 10000; g++) {
        for (let t = 0; t < topics.length && patternCount < 10000; t++) {
          for (let r = 0; r < responses.length && patternCount < 10000; r++) {
            for (let e = 0; e < emotions.length && patternCount < 10000; e++) {
              patterns.push({
                greeting: greetings[g],
                topic: topics[t],
                response: responses[r],
                emotion: emotions[e],
                type: 'basic'
              });
              patternCount++;
            }
          }
        }
      }

      // 接続詞パターン（約25,000パターン）
      for (let g = 0; g < greetings.length && patternCount < 35000; g++) {
        for (let t = 0; t < topics.length && patternCount < 35000; t++) {
          for (let c = 0; c < connectors.length && patternCount < 35000; c++) {
            for (let r = 0; r < responses.length && patternCount < 35000; r++) {
              for (let e = 0; e < emotions.length && patternCount < 35000; e++) {
                patterns.push({
                  greeting: greetings[g],
                  topic: topics[t],
                  connector: connectors[c],
                  response: responses[r],
                  emotion: emotions[e],
                  type: 'connector'
                });
                patternCount++;
              }
            }
          }
        }
      }

      // 終了語パターン（約35,000パターン）
      for (let g = 0; g < greetings.length && patternCount < 70000; g++) {
        for (let t = 0; t < topics.length && patternCount < 70000; t++) {
          for (let r = 0; r < responses.length && patternCount < 70000; r++) {
            for (let end = 0; end < endings.length && patternCount < 70000; end++) {
              for (let e = 0; e < emotions.length && patternCount < 70000; e++) {
                patterns.push({
                  greeting: greetings[g],
                  topic: topics[t],
                  response: responses[r],
                  ending: endings[end],
                  emotion: emotions[e],
                  type: 'ending'
                });
                patternCount++;
              }
            }
          }
        }
      }

      // 複合パターン（約30,000パターン）
      for (let g = 0; g < greetings.length && patternCount < 100000; g++) {
        for (let t = 0; t < topics.length && patternCount < 100000; t++) {
          for (let c = 0; c < connectors.length && patternCount < 100000; c++) {
            for (let r = 0; r < responses.length && patternCount < 100000; r++) {
              for (let end = 0; end < endings.length && patternCount < 100000; end++) {
                for (let e = 0; e < emotions.length && patternCount < 100000; e++) {
                  patterns.push({
                    greeting: greetings[g],
                    topic: topics[t],
                    connector: connectors[c],
                    response: responses[r],
                    ending: endings[end],
                    emotion: emotions[e],
                    type: 'complex'
                  });
                  patternCount++;
                }
              }
            }
          }
        }
      }

      console.log(`生成された会話パターン数: ${patterns.length}`);
      return patterns;
    }

    function getTime() {
      const now = new Date();
      return `今の時刻は ${now.getHours()}時${now.getMinutes()}分 です。`;
    }

    function getDate() {
      const now = new Date();
      return `今日は ${now.getFullYear()}年${now.getMonth()+1}月${now.getDate()}日 です。`;
    }

    // 天気・気温情報を取得
    async function getWeather() {
      try {
        const selectedCity = userPreferences.selectedCity;
        const cityInfo = cityData[selectedCity];
        console.log(`${cityInfo.name}の気温情報を取得中...`);
        
        // 選択された都市の気温を取得
        const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${cityInfo.latitude}&longitude=${cityInfo.longitude}&current=temperature_2m,relative_humidity_2m,weather_code&timezone=${cityInfo.timezone}`);
        
        if (response.ok) {
          const data = await response.json();
          console.log(`${cityInfo.name}の気温データ取得成功:`, data);
          
          const temp = Math.round(data.current.temperature_2m);
          const humidity = data.current.relative_humidity_2m;
          const weatherCode = data.current.weather_code;
          
          // 天気コードを日本語に変換
          const weatherText = getWeatherText(weatherCode);
          
          // 気温に基づくコメント
          let tempComment = '';
          if (temp >= 30) {
            tempComment = 'とても暑いですね！水分補給を忘れずに。';
          } else if (temp >= 25) {
            tempComment = '暑いですね。適度に冷房を使いましょう。';
          } else if (temp >= 20) {
            tempComment = '過ごしやすい気温ですね。';
          } else if (temp >= 15) {
            tempComment = '少し肌寒いですね。上着があると良いでしょう。';
          } else if (temp >= 10) {
            tempComment = '寒いですね。温かい格好をしましょう。';
          } else {
            tempComment = 'とても寒いですね！防寒対策をしっかりと。';
          }
          
          const result = `🌤️ 現在の天気情報（${cityInfo.name}）:\n` +
                 `🌡️ 気温: ${temp}°C\n` +
                 `☁️ 天気: ${weatherText}\n` +
                 `💧 湿度: ${humidity}%\n` +
                 `💬 ${tempComment}`;
          
          console.log('気温情報生成完了:', result);
          return result;
        } else {
          console.log('API応答エラー、代替情報を使用');
          // APIが利用できない場合の代替案
          return getWeatherFallback();
        }
      } catch (error) {
        console.error('天気情報取得エラー:', error);
        console.log('エラー発生、代替情報を使用');
        return getWeatherFallback();
      }
    }
    
    // 天気コードを日本語に変換
    function getWeatherText(code) {
      const weatherMap = {
        0: '快晴',
        1: '晴れ',
        2: '晴れ時々曇り',
        3: '曇り',
        45: '霧',
        48: '霧',
        51: '小雨',
        53: '雨',
        55: '雨',
        56: '小雨',
        57: '雨',
        61: '雨',
        63: '雨',
        65: '大雨',
        66: '小雨',
        67: '雨',
        71: '小雪',
        73: '雪',
        75: '大雪',
        77: '雪',
        80: '小雨',
        81: '雨',
        82: '大雨',
        85: '小雪',
        86: '大雪',
        95: '雷雨',
        96: '雷雨',
        99: '雷雨'
      };
      return weatherMap[code] || '不明';
    }
    
    // 天気情報が取得できない場合の代替案
    function getWeatherFallback() {
      const selectedCity = userPreferences.selectedCity;
      const cityInfo = cityData[selectedCity];
      const now = new Date();
      const month = now.getMonth() + 1;
      const hour = now.getHours();
      
      // 季節と時間帯に基づく推定気温
      let estimatedTemp = 20;
      let season = '';
      
      if (month >= 3 && month <= 5) {
        season = '春';
        estimatedTemp = 15 + Math.floor(Math.random() * 10);
      } else if (month >= 6 && month <= 8) {
        season = '夏';
        estimatedTemp = 25 + Math.floor(Math.random() * 10);
      } else if (month >= 9 && month <= 11) {
        season = '秋';
        estimatedTemp = 15 + Math.floor(Math.random() * 10);
      } else {
        season = '冬';
        estimatedTemp = 5 + Math.floor(Math.random() * 10);
      }
      
      // 都市による気温調整
      if (selectedCity === 'Osaka') {
        // 大阪は東京より少し暖かい傾向
        estimatedTemp += 1;
      }
      
      // 時間帯による調整
      if (hour >= 6 && hour <= 10) {
        estimatedTemp -= 2; // 朝は涼しい
      } else if (hour >= 14 && hour <= 16) {
        estimatedTemp += 3; // 午後は暑い
      } else if (hour >= 22 || hour <= 4) {
        estimatedTemp -= 3; // 夜は涼しい
      }
      
      const tempComment = getTempComment(estimatedTemp);
      
      return `🌤️ 推定天気情報（${cityInfo.name}・${season}）:\n` +
             `🌡️ 推定気温: ${estimatedTemp}°C\n` +
             `☁️ 天気: 晴れ時々曇り\n` +
             `💬 ${tempComment}\n` +
             `ℹ️ 注: これは推定値です。正確な情報は天気予報サイトをご確認ください。`;
    }
    
    // 気温に基づくコメント生成
    function getTempComment(temp) {
      if (temp >= 30) {
        return 'とても暑いですね！水分補給を忘れずに。';
      } else if (temp >= 25) {
        return '暑いですね。適度に冷房を使いましょう。';
      } else if (temp >= 20) {
        return '過ごしやすい気温ですね。';
      } else if (temp >= 15) {
        return '少し肌寒いですね。上着があると良いでしょう。';
      } else if (temp >= 10) {
        return '寒いですね。温かい格好をしましょう。';
      } else {
        return 'とても寒いですね！防寒対策をしっかりと。';
      }
    }

    // ネット検索機能（検索結果のURLを提供）
    function searchWeb(query) {
      const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(query)}`;
      const japaneseSearchUrl = `https://www.google.co.jp/search?q=${encodeURIComponent(query)}`;
      const youtubeSearchUrl = `https://www.youtube.com/results?search_query=${encodeURIComponent(query)}`;
      const wikipediaSearchUrl = `https://ja.wikipedia.org/wiki/${encodeURIComponent(query)}`;
      const bingSearchUrl = `https://www.bing.com/search?q=${encodeURIComponent(query)}`;
      const yahooSearchUrl = `https://search.yahoo.co.jp/search?p=${encodeURIComponent(query)}`;
      const amazonSearchUrl = `https://www.amazon.co.jp/s?k=${encodeURIComponent(query)}`;
      const rakutenSearchUrl = `https://search.rakuten.co.jp/search/insight/?sitem=${encodeURIComponent(query)}`;
      
      return `🔍 「${query}」について検索結果を提供します：

🔍 <a href="${japaneseSearchUrl}" target="_blank" style="color: #1f6feb; text-decoration: underline;">Google検索（日本語）</a>
🌐 <a href="${searchUrl}" target="_blank" style="color: #1f6feb; text-decoration: underline;">Google検索（英語）</a>
📺 <a href="${youtubeSearchUrl}" target="_blank" style="color: #1f6feb; text-decoration: underline;">YouTube検索</a>
📚 <a href="${wikipediaSearchUrl}" target="_blank" style="color: #1f6feb; text-decoration: underline;">Wikipedia検索</a>
🔎 <a href="${bingSearchUrl}" target="_blank" style="color: #1f6feb; text-decoration: underline;">Bing検索</a>
📱 <a href="${yahooSearchUrl}" target="_blank" style="color: #1f6feb; text-decoration: underline;">Yahoo!検索</a>
🛒 <a href="${amazonSearchUrl}" target="_blank" style="color: #1f6feb; text-decoration: underline;">Amazon検索</a>
🎁 <a href="${rakutenSearchUrl}" target="_blank" style="color: #1f6feb; text-decoration: underline;">楽天検索</a>

上記のリンクをクリックして、詳細な情報を確認してください。`;
    }

    function getRandomConversation() {
      const randomIndex = Math.floor(Math.random() * conversationPatterns.length);
      const pattern = conversationPatterns[randomIndex];
      
      let response = "";
      
      switch (pattern.type) {
        case 'basic':
          response = `${pattern.greeting}！${pattern.topic}について${pattern.response}${pattern.emotion}`;
          break;
        case 'connector':
          response = `${pattern.greeting}！${pattern.topic}について${pattern.connector}${pattern.response}${pattern.emotion}`;
          break;
        case 'ending':
          response = `${pattern.greeting}！${pattern.topic}について${pattern.response}${pattern.ending}${pattern.emotion}`;
          break;
        case 'complex':
          response = `${pattern.greeting}！${pattern.topic}について${pattern.connector}${pattern.response}${pattern.ending}${pattern.emotion}`;
          break;
      }
      
      return response;
    }

    // 質問への応答
    function getQuestionResponse() {
      const responses = [
        '良い質問ですね！私にできる限り詳しくお答えします。',
        'その質問、とても興味深いです。一緒に考えてみましょう。',
        '質問していただいてありがとうございます。何かお手伝いできることがあれば教えてください。',
        'その疑問、解決できるといいですね。'
      ];
      return responses[Math.floor(Math.random() * responses.length)];
    }

    // 依頼への応答
    function getRequestResponse() {
      const responses = [
        'もちろんです！お手伝いさせていただきます。',
        '喜んでお手伝いします。どんなことでしょうか？',
        'お手伝いできることがあれば、いつでも言ってください。',
        '私にできることがあれば、全力でサポートします。'
      ];
      return responses[Math.floor(Math.random() * responses.length)];
    }

    // 感謝への応答
    function getGratitudeResponse() {
      const responses = [
        'どういたしまして！お役に立てて嬉しいです。',
        'ありがとうございます。また何かあればいつでもお声がけください。',
        'お礼を言っていただいて、とても嬉しいです。',
        'こちらこそ、ありがとうございます。',
        'どういたしまして！また何かあればいつでも。',
        'ありがとうございます。お役に立てて光栄です。',
        'どういたしまして。楽しい会話でした。',
        'ありがとうございます。またお話ししましょうね。'
      ];
      return responses[Math.floor(Math.random() * responses.length)];
    }

    function getGreetingResponse() {
      const responses = [
        'こんにちは！今日もよろしくお願いします。',
        'やあ！元気ですか？',
        'こんにちは！何かお手伝いできることはありますか？',
        'おはようございます！今日も一日頑張りましょう。',
        'こんばんは！今日はどんな一日でしたか？',
        'はじめまして！よろしくお願いします。',
        'やあ！久しぶりですね。',
        'こんにちは！今日も素晴らしい一日にしましょう。'
      ];
      return responses[Math.floor(Math.random() * responses.length)];
    }

    function getFarewellResponse() {
      const responses = [
        'さようなら！またお話ししましょうね。',
        'バイバイ！またね。',
        'お疲れ様でした。またお会いしましょう。',
        'さようなら！良い一日をお過ごしください。',
        'またね！元気でね。',
        'お疲れ様でした。ゆっくり休んでくださいね。',
        'さようなら！明日も良い一日になりますように。',
        'またお話ししましょう！お疲れ様でした。'
      ];
      return responses[Math.floor(Math.random() * responses.length)];
    }
    
    // 新しい応答関数群
    function getConsultationResponse(analysis) {
      const responses = [
        'お悩みを聞かせていただき、ありがとうございます。一緒に考えさせていただきますね。',
        'とても大切なご相談ですね。どんな小さなことでも、遠慮なくお話しください。',
        'お困りのこと、よく分かります。私にできる限りのサポートをさせていただきます。',
        'ご相談いただけて嬉しいです。あなたの気持ちに寄り添いたいと思います。'
      ];
      return responses[Math.floor(Math.random() * responses.length)];
    }
    
    function getInformationResponse(analysis) {
      const responses = [
        'お知らせいただき、ありがとうございます。とても興味深い情報ですね。',
        'そうなんですね！教えていただき、ありがとうございます。',
        '貴重な情報をありがとうございます。とても参考になります。',
        'そのような出来事があったのですね。詳しく教えていただけますか？'
      ];
      return responses[Math.floor(Math.random() * responses.length)];
    }
    
    function getHighPositiveResponse(analysis) {
      const responses = [
        'わあ！それは素晴らしいニュースですね！私も一緒に喜ばせてください！',
        'なんて素敵なことでしょう！あなたの喜びが私にも伝わってきます！',
        '本当に良かったですね！心から祝福させていただきます！',
        'それは最高ですね！あなたの幸せそうな様子が目に浮かびます！'
      ];
      return responses[Math.floor(Math.random() * responses.length)];
    }
    
    function getHighNegativeResponse(analysis) {
      const responses = [
        'とても辛い状況ですね。あなたの気持ち、とてもよく分かります。',
        'そんなに大変な思いをされているのですね。一人で抱え込まないでください。',
        '本当に苦しい状況ですね。私はあなたの味方です。',
        'とても深刻な問題ですね。一緒に解決策を考えさせてください。'
      ];
      return responses[Math.floor(Math.random() * responses.length)];
    }
    
    function getQuestionResponseByType(analysis) {
      switch(analysis.questionType) {
        case 'opinion':
          return 'とても興味深い質問ですね。私の考えをお話しさせていただきますね。';
        case 'specific':
          return '具体的な質問をありがとうございます。詳しくお答えできるよう努めます。';
        case 'explanation':
          return 'なるほど、理由や背景について知りたいのですね。分かりやすく説明させていただきます。';
        default:
          return '良い質問ですね！一緒に考えてみましょう。';
      }
    }
    
    function getTopicContinuationResponse(analysis) {
      const responses = [
        'その話の続き、とても気になります。もっと詳しく聞かせてください。',
        'さっきの話題の続きですね。とても興味深いです。',
        'その件について、もう少し教えていただけますか？',
        'その話、続きが気になります。どうなったのでしょうか？'
      ];
      return responses[Math.floor(Math.random() * responses.length)];
    }
    
    function getPersonalResponse(analysis) {
      const responses = [
        'あなたのことを教えてくださって、ありがとうございます。',
        'そうなんですね。あなたのお話、とても興味深いです。',
        'ご自身のことをお話しくださり、嬉しいです。',
        'あなたのことがよく分かりました。もっと聞かせてください。'
      ];
      return responses[Math.floor(Math.random() * responses.length)];
    }

    // コンテキストを考慮した応答生成
    function generateContextualResponse(analysis) {
      try {
        // 会話履歴に追加
        conversationHistory.push({
          user: analysis.keywords.join(', '),
          timestamp: new Date(),
          sentiment: analysis.sentiment,
          topic: analysis.topic
        });
        
        // 最新の5件のみ保持
        if (conversationHistory.length > 5) {
          conversationHistory.shift();
        }
        
        // コンテキストを更新
        updateConversationContext(analysis);
        
        // 適切な応答パターンを選択
        const responsePattern = selectResponsePattern(analysis);
        
        // 応答を生成
        let response = responsePattern;
        
        // ユーザー設定に基づく応答のカスタマイズ
        response = customizeResponseByPreferences(response);
        
        // ユーザーの興味に関連する話題を追加（30%の確率）
        if (conversationContext.interests.length > 0 && Math.random() < 0.3) {
          const randomInterest = conversationContext.interests[Math.floor(Math.random() * conversationContext.interests.length)];
          const interestResponses = {
            'work': [
              ' 仕事の話、とても興味深いですね。',
              ' お仕事お疲れ様です。他にも何かありますか？',
              ' 仕事の話、聞くのが大好きです。',
              ' お仕事について、もっと詳しく聞かせてください。'
            ],
            'hobby': [
              ' 趣味の話、聞くのが大好きです。',
              ' 趣味があると人生が豊かになりますよね。',
              ' その趣味、とても素敵ですね。',
              ' 趣味の話、続きを聞かせてください。'
            ],
            'family': [
              ' 家族の話、温かみがあって素敵ですね。',
              ' 家族との時間、とても貴重ですね。',
              ' 家族の話、聞くのが大好きです。',
              ' 家族について、もっと教えてください。'
            ],
            'health': [
              ' 健康について考えるのは大切ですね。',
              ' 健康は何より大切ですよね。',
              ' 体調管理、しっかりされていますか？',
              ' 健康について、何か気になることはありますか？'
            ],
            'technology': [
              ' テクノロジーの話、とても面白いです。',
              ' 技術の進歩、すごいですね。',
              ' テクノロジーについて、もっと詳しく聞かせてください。',
              ' その技術、とても興味深いです。'
            ],
            'food': [
              ' 食べ物の話、楽しいですね。',
              ' 食べ物の話、聞くのが大好きです。',
              ' その食べ物、とても美味しそうですね。',
              ' 食べ物について、もっと教えてください。'
            ],
            'weather': [
              ' 天気の話、日常的で親しみやすいですね。',
              ' 天気について、何か気になることはありますか？',
              ' 天気の話、とても身近で良いですね。',
              ' 今日の天気、いかがですか？'
            ]
          };
          
          if (interestResponses[randomInterest]) {
            const responses = interestResponses[randomInterest];
            response += responses[Math.floor(Math.random() * responses.length)];
          }
        }
        
        // 会話の継続性を保つ（20%の確率）
        if (conversationContext.conversationLength > 2 && Math.random() < 0.2) {
          const continuations = [
            ' 他にも何かお話したいことはありますか？',
            ' 他に何か楽しい話はありますか？',
            ' 他にも何かお手伝いできることはありますか？',
            ' 他に何か気になることはありますか？',
            ' 他にも何か聞かせてください。'
          ];
          response += continuations[Math.floor(Math.random() * continuations.length)];
        }
        
        // 時々、完全にランダムな応答を混ぜる（10%の確率）
        if (Math.random() < 0.1) {
          const randomResponses = [
            ' 今日は何か特別なことがありましたか？',
            ' 最近、何か新しい発見はありましたか？',
            ' 今日はどんな気分ですか？',
            ' 何か楽しい予定はありますか？',
            ' 最近、何か興味深いことはありましたか？',
            ' 今日はどんな一日でしたか？',
            ' 何かお手伝いできることはありますか？'
          ];
          response += randomResponses[Math.floor(Math.random() * randomResponses.length)];
        }
        
        return response;
      } catch (error) {
        console.error('コンテキスト応答生成エラー:', error);
        return '申し訳ございません。エラーが発生しました。もう一度お試しください。';
      }
    }
    
    // ユーザー設定に基づく応答のカスタマイズ
    function customizeResponseByPreferences(response) {
      // ユーザー名の置換
      if (userPreferences.userName) {
        response = response.replace(/ユーザー/g, `${userPreferences.userName}さん`);
        response = response.replace(/あなた/g, `${userPreferences.userName}さん`);
      }
      
      // 性格に基づく応答の調整
      switch (userPreferences.personality) {
        case 'formal':
          response = response.replace(/です。/g, 'でございます。');
          response = response.replace(/ます。/g, 'ます。');
          break;
        case 'humorous':
          if (Math.random() < 0.3) {
            response += ' 😊';
          }
          break;
        case 'professional':
          response = response.replace(/ね。/g, '。');
          response = response.replace(/ね。/g, '。');
          break;
      }
      
      // 応答スタイルの調整
      switch (userPreferences.responseStyle) {
        case 'concise':
          if (response.length > 100) {
            response = response.split('。')[0] + '。';
          }
          break;
        case 'cute':
          if (Math.random() < 0.5) {
            response += ' ✨';
          }
          break;
      }
      
      return response;
    }

    async function aiReply(text) {
      try {
        // まず、ユーザー命令の処理を優先
        const commandResponse = processUserCommand(text);
        if (commandResponse) {
          return commandResponse;
        }
        
        // 検索意図の検出と処理
        if (text.includes("検索") || text.includes("調べて") || text.includes("教えて") || text.includes("探して")) {
          const searchQuery = extractSearchQuery(text);
          if (searchQuery) {
            return searchWeb(searchQuery);
          }
        }
        
        // 短い単語の検索処理
        const shortWordPattern = /^[あ-んア-ン一-龯]{1,3}$/;
        if (shortWordPattern.test(text.trim())) {
          const shortWords = [
            '猫', '犬', '人', '車', '家', '本', '花', '木', '山', '海', '空', '月', '星', '風', '雨',
            '鳥', '魚', '虫', '草', '石', '水', '火', '土', '金', '銀', '銅', '鉄', '紙', '布', '糸',
            '米', '麦', '豆', '肉', '魚', '卵', '牛', '馬', '羊', '豚', '鶏', '鴨', '鯉', '鮭', '鰻',
            '桜', '梅', '松', '竹', '菊', '蘭', '薔薇', '百合', '蓮', '牡丹', '椿', '紫陽花', '朝顔',
            '東京', '大阪', '京都', '横浜', '名古屋', '神戸', '福岡', '札幌', '仙台', '広島', '金沢',
            '富士', '箱根', '日光', '鎌倉', '奈良', '姫路', '姫路城', '天守閣', '神社', '寺', '教会',
            '学校', '会社', '病院', '銀行', '郵便局', '警察署', '消防署', '図書館', '美術館', '博物館',
            '駅', '空港', '港', '橋', 'トンネル', '道路', '公園', '広場', '市場', '商店街', 'デパート',
            'レストラン', 'カフェ', '居酒屋', 'バー', 'パブ', 'クラブ', 'ホテル', '旅館', '民宿', 'キャンプ場',
            'テレビ', 'ラジオ', '新聞', '雑誌', '本', '漫画', '小説', '詩', '歌', '音楽', '映画', 'ドラマ',
            'ゲーム', 'スポーツ', '野球', 'サッカー', 'テニス', 'ゴルフ', 'スキー', 'スノーボード', 'サーフィン',
            '料理', '和食', '洋食', '中華', 'イタリアン', 'フレンチ', 'エスニック', 'スイーツ', 'ケーキ', 'パン',
            'お酒', 'ビール', 'ワイン', '日本酒', '焼酎', 'ウイスキー', 'ブランデー', 'カクテル', 'ジュース', 'お茶',
            'コーヒー', '紅茶', '緑茶', '抹茶', '麦茶', '玄米茶', 'ほうじ茶', '烏龍茶', 'プーアール茶', 'ジャスミン茶',
            '愛', '恋', '夢', '希望', '未来', '過去', '現在', '時間', '空間', '世界', '地球', '宇宙',
            '太陽', '地球', '火星', '金星', '木星', '土星', '天王星', '海王星', '冥王星', '彗星', '流星',
            '春', '夏', '秋', '冬', '朝', '昼', '夜', '夕方', '深夜', '午前', '午後', '正午', '真夜中',
            '友達', '家族', '恋人', '先生', '生徒', '学生', '大人', '子供', '赤ちゃん', 'お年寄り',
            '男', '女', '男性', '女性', '少年', '少女', '青年', '中年', '高齢者', '若者',
            '手', '足', '目', '耳', '鼻', '口', '頭', '髪', '肌', '心', '体', '魂', '精神',
            '色', '音', '匂い', '味', '触感', '温度', '湿度', '圧力', '重力', '電気', '磁気',
            '言葉', '文字', '数字', '記号', '絵', '写真', '映像', '動画', '音声', 'データ',
            '情報', '知識', '知恵', '経験', '記憶', '感情', '思考', '想像', '創造', '発明',
            '発見', '研究', '実験', '観察', '分析', '計算', '測定', '比較', '分類', '整理'
          ];
          
          if (shortWords.includes(text.trim())) {
            const searchIntent = confirm(`${text.trim()}について検索しますか？`);
            if (searchIntent) {
              return searchWeb(text.trim());
            }
          }
        }
        
        // 一般的な検索パターンの処理
        const searchPatterns = [
          /^(.{1,10})(について|とは|って|の情報|を教えて|を調べて|を検索して|を探して)$/,
          /^(.{1,10})(って何|とは何|について教えて|について調べて|について検索して)$/,
          /^(.{1,10})(の詳細|の説明|の意味|の定義|の歴史|の特徴|の種類|の作り方|の食べ方|の使い方)$/
        ];
        
        for (let pattern of searchPatterns) {
          const match = text.match(pattern);
          if (match && match[1] && match[1].length >= 1) {
            return searchWeb(match[1].trim());
          }
        }
        
        // 時間・日付・天気の処理
        if (text.includes("時間") || text.includes("時刻")) return getTime();
        if (text.includes("日付") || text.includes("今日は")) return getDate();
        if (text.includes("天気")) return getWeather();

        // 気温に関する質問
        if (text.includes("気温") || text.includes("温度") || text.includes("暑い") || text.includes("寒い") || text.includes("何度")) {
          const weatherInfo = await getWeather();
          return weatherInfo;
        }
        
        // 感情・意図・トピックの分析
        const analysis = analyzeUserMessage(text);
        
        // 学習ベースの応答生成
        let reply = await generateLearningBasedResponse(text, analysis);
        
        // 応答のパーソナライズ
        reply = customizeResponseByPreferences(reply);
        
        // 学習データに記録
        learnConversationPattern(text, reply, analysis);
        
        // 会話履歴とコンテキストを更新
        conversationHistory.push({ role: 'user', content: text });
        conversationHistory.push({ role: 'assistant', content: reply });
        updateConversationContext(analysis);
        
        return reply;
      } catch (error) {
        console.error('AI Reply Error:', error);
        return 'すみません、応答の生成中にエラーが発生しました。もう一度お試しください。';
      }
    }

    async function addMessage(who, text) {
      const div = document.createElement("div");
      div.className = `msg ${who}`;
      div.innerHTML = text;
      chat.appendChild(div);
      chat.scrollTop = chat.scrollHeight;
      
      // チャット履歴をデータベースに保存
      try {
        const response = await fetch('save_chat.php', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            message: text,
            message_type: who
          })
        });
        
        const data = await response.json();
        if (!data.success) {
          console.error('チャット履歴保存エラー:', data.message);
        }
      } catch (error) {
        console.error('チャット履歴保存エラー:', error);
      }
    }

    function showTypingIndicator() {
      const indicator = document.createElement("div");
      indicator.className = "typing-indicator";
      indicator.innerHTML = `
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
      `;
      indicator.id = "typing-indicator";
      chat.appendChild(indicator);
      chat.scrollTop = chat.scrollHeight;
      return indicator;
    }

    function removeTypingIndicator() {
      const indicator = document.getElementById("typing-indicator");
      if (indicator) {
        indicator.remove();
      }
    }

    async function sendMessage() {
      const text = input.value.trim();
      if (!text) return;
      
      console.log('📤 メッセージ送信開始:', text);
      
      addMessage("user", text);
      input.value = "";
      
      // タイピングインジケーターを表示
      const typingIndicator = showTypingIndicator();
      
      setTimeout(async () => {
        removeTypingIndicator();
        try {
          console.log(' AI応答生成開始...');
          const reply = await aiReply(text);
          console.log('✅ AI応答生成完了:', reply);
          addMessage("ai", reply);
        } catch (error) {
          console.error('❌ AI応答生成エラー:', error);
          addMessage("ai", "申し訳ございません。エラーが発生しました。もう一度お試しください。");
        }
      }, 1000 + Math.random() * 1000); // 1-2秒のランダム遅延
    }

    send.addEventListener("click", sendMessage);
    
    input.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        sendMessage();
      }
    });

    // ログアウト処理
    document.getElementById('logout-btn').addEventListener('click', async function() {
      try {
        const response = await fetch('logout.php');
        const data = await response.json();
        
        if (data.success) {
          // ローカルストレージをクリア
          localStorage.removeItem('user_id');
          localStorage.removeItem('user_name');
          localStorage.removeItem('is_logged_in');
          
          // ログインページにリダイレクト
          window.location.href = 'login.html';
        }
      } catch (error) {
        console.error('ログアウトエラー:', error);
        // エラーが発生してもローカルストレージをクリアしてリダイレクト
        localStorage.clear();
        window.location.href = 'login.html';
      }
    });

    // フォーカス設定
    input.focus();
    
    // 学習データストレージ
    let learningData = {
      conversationPatterns: [],
      userBehavior: {},
      topicPreferences: {},
      responseQuality: {},
      contextMemory: [],
      apiUsageCount: 0
    };
    
    // 高度な感情分析クラス
    class AdvancedEmotionAnalyzer {
      constructor() {
        this.emotionLexicon = this.buildEmotionLexicon();
        this.contextRules = this.buildContextRules();
        this.emphasisPatterns = this.buildEmphasisPatterns();
        this.politenessLevels = this.buildPolitenessLevels();
      }
      
      analyze(message) {
        const emotions = this.detectEmotions(message);
        const primarySentiment = this.determinePrimarySentiment(emotions);
        const intensity = this.calculateIntensity(emotions);
        const confidence = this.calculateConfidence(emotions);
        const complexity = this.analyzeComplexity(message);
        const politeness = this.analyzePoliteness(message);
        const sarcasm = this.detectSarcasm(message, emotions);
        const emphasis = this.detectEmphasis(message);
        
        return {
          emotions,
          primarySentiment,
          intensity,
          confidence,
          complexity,
          politeness,
          sarcasm,
          emphasis
        };
      }
      
      detectEmotions(message) {
        const emotions = {
          joy: 0, sadness: 0, anger: 0, fear: 0, surprise: 0, disgust: 0,
          trust: 0, anticipation: 0, love: 0, contempt: 0, confusion: 0, excitement: 0
        };
        
        // 感情キーワードの検出
        for (const [emotion, keywords] of Object.entries(this.emotionLexicon)) {
          for (const keyword of keywords) {
            if (message.includes(keyword.text)) {
              emotions[emotion] += keyword.weight;
              
              // 文脈ルールの適用
              const contextMultiplier = this.applyContextRules(keyword, message);
              emotions[emotion] *= contextMultiplier;
            }
          }
        }
        
        // 感情の正規化
        for (const emotion in emotions) {
          emotions[emotion] = Math.max(0, Math.min(10, emotions[emotion]));
        }
        
        return emotions;
      }
      
      determinePrimarySentiment(emotions) {
        let maxEmotion = 'neutral';
        let maxValue = 0;
        
        for (const [emotion, value] of Object.entries(emotions)) {
          if (value > maxValue) {
            maxValue = value;
            maxEmotion = emotion;
          }
        }
        
        // 感情の分類
        if (maxValue < 2) return 'neutral';
        
        const positiveEmotions = ['joy', 'love', 'trust', 'anticipation', 'excitement'];
        const negativeEmotions = ['sadness', 'anger', 'fear', 'disgust', 'contempt', 'confusion'];
        
        if (positiveEmotions.includes(maxEmotion)) return 'positive';
        if (negativeEmotions.includes(maxEmotion)) return 'negative';
        
        return 'neutral';
      }
      
      calculateIntensity(emotions) {
        const totalIntensity = Object.values(emotions).reduce((sum, value) => sum + value, 0);
        const averageIntensity = totalIntensity / Object.keys(emotions).length;
        
        // -5から+5のスケールに変換
        if (averageIntensity < 2) return 0;
        if (averageIntensity < 4) return averageIntensity - 2;
        if (averageIntensity < 6) return averageIntensity - 3;
        if (averageIntensity < 8) return averageIntensity - 2;
        return 5;
      }
      
      calculateConfidence(emotions) {
        const maxEmotion = Math.max(...Object.values(emotions));
        const totalEmotions = Object.values(emotions).reduce((sum, value) => sum + value, 0);
        
        // 感情の強度と一貫性から信頼度を計算
        const intensityScore = maxEmotion / 10;
        const consistencyScore = maxEmotion / (totalEmotions / Object.keys(emotions).length);
        
        return Math.min(1, (intensityScore + consistencyScore) / 2);
      }
      
      analyzeComplexity(message) {
        const wordCount = message.split(/\s+/).length;
        const hasComplexStructures = /[、。！？]/.test(message);
        const hasEmojis = /[\u{1F600}-\u{1F64F}]/u.test(message);
        
        if (wordCount > 20 || hasComplexStructures) return 'complex';
        if (wordCount > 10) return 'medium';
        return 'simple';
      }
      
      analyzePoliteness(message) {
        const formalPatterns = [/です/, /ます/, /ございます/, /いたします/];
        const casualPatterns = [/だ/, /である/, /だよ/, /だね/];
        
        let formalCount = 0;
        let casualCount = 0;
        
        formalPatterns.forEach(pattern => {
          if (pattern.test(message)) formalCount++;
        });
        
        casualPatterns.forEach(pattern => {
          if (pattern.test(message)) casualCount++;
        });
        
        if (formalCount > casualCount) return 'formal';
        if (casualCount > formalCount) return 'casual';
        return 'neutral';
      }
      
      detectSarcasm(message, emotions) {
        // 皮肉の検出パターン
        const sarcasmPatterns = [
          /本当に/, /まあ/, /そうですね/, /確かに/, /なるほど/
        ];
        
        const hasSarcasmPattern = sarcasmPatterns.some(pattern => pattern.test(message));
        const emotionMismatch = this.detectEmotionMismatch(message, emotions);
        
        return hasSarcasmPattern && emotionMismatch;
      }
      
      detectEmphasis(message) {
        const emphasis = [];
        
        // 強調表現の検出
        if (/！+/.test(message)) emphasis.push('exclamation');
        if (/？+/.test(message)) emphasis.push('question');
        if (/\.{3,}/.test(message)) emphasis.push('ellipsis');
        if (/[「」『』]/.test(message)) emphasis.push('quotes');
        if (/[【】]/.test(message)) emphasis.push('brackets');
        
        return emphasis;
      }
      
      buildEmotionLexicon() {
        return {
          joy: [
            { text: '嬉しい', weight: 3 },
            { text: '楽しい', weight: 3 },
            { text: '幸せ', weight: 4 },
            { text: '喜び', weight: 4 },
            { text: '笑顔', weight: 2 },
            { text: '楽しみ', weight: 3 },
            { text: '最高', weight: 5 },
            { text: '素晴らしい', weight: 4 }
          ],
          sadness: [
            { text: '悲しい', weight: 3 },
            { text: '寂しい', weight: 3 },
            { text: '落ち込み', weight: 4 },
            { text: '涙', weight: 3 },
            { text: '嘆き', weight: 4 },
            { text: '憂鬱', weight: 4 }
          ],
          anger: [
            { text: '怒り', weight: 4 },
            { text: '腹立つ', weight: 4 },
            { text: 'イライラ', weight: 3 },
            { text: '憤り', weight: 4 },
            { text: '激怒', weight: 5 },
            { text: '憤慨', weight: 4 }
          ],
          fear: [
            { text: '怖い', weight: 3 },
            { text: '恐れ', weight: 4 },
            { text: '不安', weight: 3 },
            { text: '心配', weight: 3 },
            { text: '恐怖', weight: 4 },
            { text: '怯え', weight: 3 }
          ],
          surprise: [
            { text: '驚き', weight: 3 },
            { text: 'びっくり', weight: 3 },
            { text: '意外', weight: 2 },
            { text: '予想外', weight: 3 },
            { text: '衝撃', weight: 4 },
            { text: '愕然', weight: 4 }
          ],
          love: [
            { text: '愛してる', weight: 5 },
            { text: '大好き', weight: 4 },
            { text: '愛', weight: 4 },
            { text: '恋', weight: 3 },
            { text: '愛情', weight: 4 }
          ],
          trust: [
            { text: '信頼', weight: 4 },
            { text: '安心', weight: 3 },
            { text: '頼もしい', weight: 3 },
            { text: '心強い', weight: 3 }
          ],
          confusion: [
            { text: '混乱', weight: 3 },
            { text: '分からない', weight: 2 },
            { text: '迷う', weight: 2 },
            { text: '困る', weight: 2 }
          ],
          excitement: [
            { text: '興奮', weight: 4 },
            { text: 'ワクワク', weight: 3 },
            { text: '期待', weight: 3 },
            { text: '希望', weight: 3 }
          ]
        };
      }
      
      buildContextRules() {
        return {
          negation: (keyword, message) => {
            // 否定語の前後の感情を反転
            const negations = ['ない', 'ません', 'じゃない', 'ではない'];
            const hasNegation = negations.some(neg => message.includes(neg));
            return hasNegation ? 0.5 : 1;
          },
          intensifier: (keyword, message) => {
            // 強調語の前後の感情を増強
            const intensifiers = ['とても', 'すごく', 'めちゃくちゃ', '超'];
            const hasIntensifier = intensifiers.some(int => message.includes(int));
            return hasIntensifier ? 1.5 : 1;
          }
        };
      }
      
      buildEmphasisPatterns() {
        return {
          exclamation: /！+/,
          question: /？+/,
          ellipsis: /\.{3,}/,
          quotes: /[「」『』]/,
          brackets: /[【】]/
        };
      }
      
      buildPolitenessLevels() {
        return {
          veryFormal: [/ございます/, /いたします/, /申し上げます/],
          formal: [/です/, /ます/],
          neutral: [/だ/, /である/],
          casual: [/だよ/, /だね/, /だわ/]
        };
      }
      
      applyContextRules(keyword, message) {
        let multiplier = 1;
        
        for (const rule of Object.values(this.contextRules)) {
          multiplier *= rule(keyword, message);
        }
        
        return multiplier;
      }
      
      detectEmotionMismatch(message, emotions) {
        // 感情と文脈の不一致を検出
        const positiveWords = ['良い', '素晴らしい', '最高'];
        const hasPositiveWords = positiveWords.some(word => message.includes(word));
        
        if (hasPositiveWords && emotions.sadness > emotions.joy) {
          return true;
        }
        
        return false;
      }
    }
    
    // 学習データの読み込み
    loadLearningData();
    
    // 検索クエリの抽出関数
    function extractSearchQuery(text) {
      const patterns = [
        /(.*?)(について|に関して|の情報|の詳細|の説明)/,
        /(.*?)(とは|って何|って|とは何)/,
        /(.*?)(を検索|を調べ|を教え|を探し|を見つけ)/
      ];
      
      for (let pattern of patterns) {
        const match = text.match(pattern);
        if (match && match[1]) {
          return match[1].trim();
        }
      }
      return null;
    }
    
    // 高度AI機能
    async function useAdvancedAI(message, analysis) {
      if (!userPreferences.useAdvancedAI || !userPreferences.openaiApiKey) {
        return null;
      }
      
      try {
        const response = await fetch('ai_api.php', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            action: 'advanced_chat',
            message: message,
            analysis: analysis,
            history: conversationHistory.slice(-10) // 最新10件の会話履歴
          })
        });
        
        const data = await response.json();
        
        if (data.success) {
          learningData.apiUsageCount++;
          saveLearningData();
          return data.data.response;
        }
      } catch (error) {
        console.error('Advanced AI Error:', error);
      }
      
      return null;
    }
    
    // 学習データの保存
    function saveLearningData() {
      localStorage.setItem('learningData', JSON.stringify(learningData));
    }
    
    // 学習データの読み込み
    function loadLearningData() {
      try {
        const saved = localStorage.getItem('learningData');
        if (saved) {
          learningData = { ...learningData, ...JSON.parse(saved) };
        }
      } catch (error) {
        console.error('Learning data load error:', error);
      }
    }
    
    // 会話パターンの学習
    function learnConversationPattern(userMessage, aiResponse, analysis) {
      if (!userPreferences.autoLearn) return;
      
      const pattern = {
        userMessage: userMessage,
        aiResponse: aiResponse,
        analysis: analysis,
        timestamp: new Date().toISOString(),
        quality: 0 // ユーザーフィードバックで更新
      };
      
      learningData.conversationPatterns.push(pattern);
      
      // パターン数を制限（最新1000件のみ保持）
      if (learningData.conversationPatterns.length > 1000) {
        learningData.conversationPatterns = learningData.conversationPatterns.slice(-1000);
      }
      
      saveLearningData();
    }
    
    // ユーザー行動の学習
    function learnUserBehavior(action, context) {
      const userId = localStorage.getItem('user_id') || 'anonymous';
      
      if (!learningData.userBehavior[userId]) {
        learningData.userBehavior[userId] = {
          messageCount: 0,
          averageMessageLength: 0,
          preferredTopics: {},
          responseTime: [],
          satisfactionRating: []
        };
      }
      
      const behavior = learningData.userBehavior[userId];
      
      switch (action) {
        case 'message_sent':
          behavior.messageCount++;
          behavior.averageMessageLength = (behavior.averageMessageLength + context.messageLength) / 2;
          break;
        case 'topic_engaged':
          if (!behavior.preferredTopics[context.topic]) {
            behavior.preferredTopics[context.topic] = 0;
          }
          behavior.preferredTopics[context.topic]++;
          break;
        case 'response_time':
          behavior.responseTime.push(context.time);
          if (behavior.responseTime.length > 100) {
            behavior.responseTime = behavior.responseTime.slice(-100);
          }
          break;
      }
      
      saveLearningData();
    }
    
    // 改善された応答生成（学習データ活用）
    async function generateLearningBasedResponse(text, analysis) {
      try {
        // 知識ベース検索
        const knowledgeResults = await externalAPI.searchKnowledgeBase(text);
        if (knowledgeResults.length > 0) {
          const enhancedResponse = await enhanceResponseWithKnowledge(text, analysis, knowledgeResults);
          if (enhancedResponse) {
            return enhancedResponse;
          }
        }
        
        // 学習パターンから類似応答を検索
        const similarPattern = findSimilarPattern(text, analysis);
        if (similarPattern && similarPattern.quality > 3) {
          return adaptResponseFromPattern(similarPattern, analysis);
        }
        
        // 従来の応答生成
        return selectResponsePattern(analysis);
      } catch (error) {
        console.error('Enhanced response generation error:', error);
        return selectResponsePattern(analysis);
      }
    }
    
    // 知識ベースによる応答強化
    async function enhanceResponseWithKnowledge(text, analysis, knowledgeResults) {
      try {
        let enhancedResponse = '';
        
        // Wikipedia情報の統合
        const wikiResult = knowledgeResults.find(result => result.type === 'wikipedia');
        if (wikiResult) {
          const wiki = wikiResult.data;
          enhancedResponse += `📚 **${wiki.title}**について\n\n`;
          enhancedResponse += `${wiki.extract}\n\n`;
          enhancedResponse += `詳細は[Wikipedia](${wiki.url})で確認できます。\n\n`;
        }
        
        // ニュース情報の統合
        const newsResult = knowledgeResults.find(result => result.type === 'news');
        if (newsResult && newsResult.data.length > 0) {
          enhancedResponse += `📰 **最新ニュース**\n\n`;
          newsResult.data.slice(0, 3).forEach(news => {
            enhancedResponse += `• [${news.title}](${news.url})\n`;
          });
          enhancedResponse += `\n`;
        }
        
        // 分析結果に基づく応答の生成
        const contextualResponse = generateContextualResponse(analysis);
        enhancedResponse += contextualResponse;
        
        return enhancedResponse;
      } catch (error) {
        console.error('Response enhancement error:', error);
        return null;
      }
    }
    
    // 高度なパターンマッチングシステム
    class AdvancedPatternMatcher {
      constructor() {
        this.semanticIndex = new Map();
        this.patternCache = new Map();
        this.similarityThreshold = 0.75;
        this.maxCacheSize = 1000;
      }
      
      findSimilarPattern(userMessage, analysis, learningData) {
        try {
          // キャッシュから高速検索
          const cacheKey = this.generateCacheKey(userMessage, analysis);
          if (this.patternCache.has(cacheKey)) {
            return this.patternCache.get(cacheKey);
          }
          
          // セマンティック検索
          const semanticResults = this.semanticSearch(userMessage, analysis);
          
          // パターンベース検索
          const patternResults = this.patternBasedSearch(userMessage, analysis, learningData);
          
          // 結果の統合とランキング
          const combinedResults = this.combineAndRankResults(semanticResults, patternResults);
          
          // 最適なパターンを選択
          const bestPattern = this.selectBestPattern(combinedResults, analysis);
          
          // キャッシュに保存
          this.cacheResult(cacheKey, bestPattern);
          
          return bestPattern;
        } catch (error) {
          console.error('Advanced Pattern Matching Error:', error);
          return null;
        }
      }
      
      semanticSearch(userMessage, analysis) {
        const results = [];
        const userEmbeddings = this.generateEmbeddings(userMessage);
        
        // セマンティックインデックスから検索
        for (const [patternId, patternData] of this.semanticIndex) {
          const similarity = this.calculateSemanticSimilarity(userEmbeddings, patternData.embeddings);
          
          if (similarity > this.similarityThreshold) {
            results.push({
              pattern: patternData.pattern,
              similarity: similarity,
              type: 'semantic',
              confidence: this.calculateConfidence(similarity, patternData.quality)
            });
          }
        }
        
        return results.sort((a, b) => b.similarity - a.similarity);
      }
      
      patternBasedSearch(userMessage, analysis, learningData) {
        const results = [];
        
        for (const pattern of learningData.conversationPatterns) {
          const score = this.calculateAdvancedSimilarity(userMessage, pattern.userMessage, analysis, pattern.analysis);
          
          if (score > this.similarityThreshold) {
            results.push({
              pattern: pattern,
              similarity: score,
              type: 'pattern',
              confidence: this.calculateConfidence(score, pattern.quality || 0)
            });
          }
        }
        
        return results.sort((a, b) => b.similarity - a.similarity);
      }
      
      calculateAdvancedSimilarity(msg1, msg2, analysis1, analysis2) {
        let totalScore = 0;
        let weights = 0;
        
        // 1. テキストの類似度（改良版）
        const textSimilarity = this.calculateTextSimilarity(msg1, msg2);
        totalScore += textSimilarity * 0.3;
        weights += 0.3;
        
        // 2. 感情の類似度（詳細版）
        const emotionSimilarity = this.calculateEmotionSimilarity(analysis1, analysis2);
        totalScore += emotionSimilarity * 0.25;
        weights += 0.25;
        
        // 3. トピックの類似度
        const topicSimilarity = this.calculateTopicSimilarity(analysis1, analysis2);
        totalScore += topicSimilarity * 0.2;
        weights += 0.2;
        
        // 4. 意図の類似度
        const intentSimilarity = this.calculateIntentSimilarity(analysis1, analysis2);
        totalScore += intentSimilarity * 0.15;
        weights += 0.15;
        
        // 5. 文脈の類似度
        const contextSimilarity = this.calculateContextSimilarity(analysis1, analysis2);
        totalScore += contextSimilarity * 0.1;
        weights += 0.1;
        
        return weights > 0 ? totalScore / weights : 0;
      }
      
      calculateTextSimilarity(msg1, msg2) {
        // 文字レベルの類似度
        const chars1 = msg1.toLowerCase().split('');
        const chars2 = msg2.toLowerCase().split('');
        const commonChars = chars1.filter(char => chars2.includes(char));
        const charSimilarity = commonChars.length / Math.max(chars1.length, chars2.length);
        
        // 単語レベルの類似度
        const words1 = msg1.toLowerCase().split(/\s+/);
        const words2 = msg2.toLowerCase().split(/\s+/);
        const commonWords = words1.filter(word => words2.includes(word));
        const wordSimilarity = commonWords.length / Math.max(words1.length, words2.length);
        
        // 文字と単語の類似度を組み合わせ
        return (charSimilarity * 0.4) + (wordSimilarity * 0.6);
      }
      
      calculateEmotionSimilarity(analysis1, analysis2) {
        if (!analysis1.emotions || !analysis2.emotions) {
          return analysis1.sentiment === analysis2.sentiment ? 1 : 0;
        }
        
        let totalSimilarity = 0;
        let emotionCount = 0;
        
        for (const emotion in analysis1.emotions) {
          if (analysis2.emotions[emotion] !== undefined) {
            const emotion1 = analysis1.emotions[emotion];
            const emotion2 = analysis2.emotions[emotion];
            
            // 感情の強度の類似度
            const intensitySimilarity = 1 - Math.abs(emotion1 - emotion2) / 10;
            totalSimilarity += intensitySimilarity;
            emotionCount++;
          }
        }
        
        return emotionCount > 0 ? totalSimilarity / emotionCount : 0;
      }
      
      calculateTopicSimilarity(analysis1, analysis2) {
        if (analysis1.topic === analysis2.topic) return 1;
        
        // トピックの階層的類似度
        const topicHierarchy = {
          'work': ['business', 'career', 'office'],
          'hobby': ['entertainment', 'leisure', 'recreation'],
          'family': ['personal', 'relationship', 'home'],
          'health': ['wellness', 'medical', 'fitness'],
          'technology': ['digital', 'computer', 'innovation']
        };
        
        for (const [mainTopic, relatedTopics] of Object.entries(topicHierarchy)) {
          if (analysis1.topic === mainTopic && relatedTopics.includes(analysis2.topic)) {
            return 0.7;
          }
          if (analysis2.topic === mainTopic && relatedTopics.includes(analysis1.topic)) {
            return 0.7;
          }
        }
        
        return 0;
      }
      
      calculateIntentSimilarity(analysis1, analysis2) {
        if (analysis1.intent === analysis2.intent) return 1;
        
        // 意図の類似性マトリックス
        const intentSimilarityMatrix = {
          'question': { 'request': 0.8, 'consultation': 0.7 },
          'request': { 'question': 0.8, 'consultation': 0.6 },
          'consultation': { 'question': 0.7, 'request': 0.6 },
          'greeting': { 'farewell': 0.5 },
          'farewell': { 'greeting': 0.5 }
        };
        
        const similarity = intentSimilarityMatrix[analysis1.intent]?.[analysis2.intent] || 0;
        return similarity;
      }
      
      calculateContextSimilarity(analysis1, analysis2) {
        let similarity = 0;
        let factors = 0;
        
        // 敬語レベルの類似度
        if (analysis1.formality && analysis2.formality) {
          similarity += analysis1.formality === analysis2.formality ? 1 : 0.5;
          factors++;
        }
        
        // 複雑さの類似度
        if (analysis1.complexity && analysis2.complexity) {
          similarity += analysis1.complexity === analysis2.complexity ? 1 : 0.5;
          factors++;
        }
        
        // 個人情報の類似度
        if (analysis1.personalInfo !== undefined && analysis2.personalInfo !== undefined) {
          similarity += analysis1.personalInfo === analysis2.personalInfo ? 1 : 0.5;
          factors++;
        }
        
        return factors > 0 ? similarity / factors : 0;
      }
      
      combineAndRankResults(semanticResults, patternResults) {
        const allResults = [...semanticResults, ...patternResults];
        
        // 重複を除去し、最高スコアを保持
        const uniqueResults = new Map();
        
        for (const result of allResults) {
          const key = result.pattern.userMessage || result.pattern.id;
          
          if (!uniqueResults.has(key) || uniqueResults.get(key).similarity < result.similarity) {
            uniqueResults.set(key, result);
          }
        }
        
        // 信頼度でソート
        return Array.from(uniqueResults.values()).sort((a, b) => b.confidence - a.confidence);
      }
      
      selectBestPattern(results, analysis) {
        if (results.length === 0) return null;
        
        // 最高信頼度のパターンを選択
        const bestResult = results[0];
        
        // 信頼度が低い場合はnullを返す
        if (bestResult.confidence < 0.6) return null;
        
        return bestResult.pattern;
      }
      
      calculateConfidence(similarity, quality) {
        // 類似度と品質から信頼度を計算
        const similarityWeight = 0.7;
        const qualityWeight = 0.3;
        
        const normalizedQuality = Math.min(quality / 5, 1); // 品質を0-1に正規化
        
        return (similarity * similarityWeight) + (normalizedQuality * qualityWeight);
      }
      
      generateEmbeddings(text) {
        // 簡易的なテキスト埋め込み生成
        const embeddings = new Array(128).fill(0);
        const chars = text.toLowerCase().split('');
        
        for (let i = 0; i < chars.length && i < 128; i++) {
          embeddings[i] = chars[i].charCodeAt(0) / 255;
        }
        
        return embeddings;
      }
      
      calculateSemanticSimilarity(emb1, emb2) {
        // コサイン類似度の計算
        let dotProduct = 0;
        let norm1 = 0;
        let norm2 = 0;
        
        for (let i = 0; i < emb1.length; i++) {
          dotProduct += emb1[i] * emb2[i];
          norm1 += emb1[i] * emb1[i];
          norm2 += emb2[i] * emb2[i];
        }
        
        const similarity = dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
        return Math.max(0, similarity); // 負の値を0に
      }
      
      generateCacheKey(userMessage, analysis) {
        return `${userMessage.substring(0, 50)}_${analysis.topic}_${analysis.intent}_${analysis.sentiment}`;
      }
      
      cacheResult(key, result) {
        if (this.patternCache.size >= this.maxCacheSize) {
          // 最も古いエントリを削除
          const firstKey = this.patternCache.keys().next().value;
          this.patternCache.delete(firstKey);
        }
        
        this.patternCache.set(key, result);
      }
      
      // セマンティックインデックスの更新
      updateSemanticIndex(pattern) {
        const embeddings = this.generateEmbeddings(pattern.userMessage);
        this.semanticIndex.set(pattern.id || Date.now(), {
          pattern: pattern,
          embeddings: embeddings,
          quality: pattern.quality || 0
        });
      }
    }
    
    // 高度なパターンマッチャーのインスタンス化
    const advancedPatternMatcher = new AdvancedPatternMatcher();
    
    // 従来のパターンマッチング関数（後方互換性のため）
    function findSimilarPattern(userMessage, analysis) {
      return advancedPatternMatcher.findSimilarPattern(userMessage, analysis, learningData);
    }
    
    function calculateSimilarity(msg1, msg2, analysis1, analysis2) {
      return advancedPatternMatcher.calculateAdvancedSimilarity(msg1, msg2, analysis1, analysis2);
    }
    
    // 外部API統合システム
    class ExternalAPIIntegration {
      constructor() {
        this.wikipediaCache = new Map();
        this.newsCache = new Map();
        this.translationCache = new Map();
        this.cacheExpiry = 30 * 60 * 1000; // 30分
      }
      
      // Wikipedia API統合
      async getWikipediaInfo(query) {
        try {
          // キャッシュチェック
          const cacheKey = `wiki_${query}`;
          const cached = this.wikipediaCache.get(cacheKey);
          if (cached && Date.now() - cached.timestamp < this.cacheExpiry) {
            return cached.data;
          }
          
          // 日本語Wikipediaから検索
          const jaResponse = await fetch(
            `https://ja.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(query)}`
          );
          
          if (jaResponse.ok) {
            const data = await jaResponse.json();
            const result = {
              title: data.title,
              extract: data.extract,
              url: data.content_urls.desktop.page,
              language: 'ja',
              thumbnail: data.thumbnail?.source || null
            };
            
            // キャッシュに保存
            this.wikipediaCache.set(cacheKey, {
              data: result,
              timestamp: Date.now()
            });
            
            return result;
          }
          
          // 英語Wikipediaから検索
          const enResponse = await fetch(
            `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(query)}`
          );
          
          if (enResponse.ok) {
            const enData = await enResponse.json();
            const result = {
              title: enData.title,
              extract: enData.extract,
              url: enData.content_urls.desktop.page,
              language: 'en',
              thumbnail: enData.thumbnail?.source || null
            };
            
            // キャッシュに保存
            this.wikipediaCache.set(cacheKey, {
              data: result,
              timestamp: Date.now()
            });
            
            return result;
          }
          
          return null;
        } catch (error) {
          console.error('Wikipedia API Error:', error);
          return null;
        }
      }
      
      // ニュースAPI統合（無料版）
      async getLatestNews(topic) {
        try {
          const cacheKey = `news_${topic}`;
          const cached = this.newsCache.get(cacheKey);
          if (cached && Date.now() - cached.timestamp < this.cacheExpiry) {
            return cached.data;
          }
          
          // 簡易的なニュース検索（実際のAPIキーが必要）
          const newsData = await this.searchNewsFromMultipleSources(topic);
          
          // キャッシュに保存
          this.newsCache.set(cacheKey, {
            data: newsData,
            timestamp: Date.now()
          });
          
          return newsData;
        } catch (error) {
          console.error('News API Error:', error);
          return [];
        }
      }
      
      // 複数ソースからのニュース検索
      async searchNewsFromMultipleSources(topic) {
        const news = [];
        
        try {
          // Google News検索（スクレイピングなし）
          const googleNewsUrl = `https://news.google.com/search?q=${encodeURIComponent(topic)}&hl=ja&gl=JP&ceid=JP:ja`;
          news.push({
            title: `${topic}に関する最新ニュース`,
            description: `Google Newsで「${topic}」を検索`,
            url: googleNewsUrl,
            source: 'Google News',
            timestamp: new Date().toISOString()
          });
          
          // Yahoo!ニュース
          const yahooNewsUrl = `https://news.yahoo.co.jp/search/?p=${encodeURIComponent(topic)}`;
          news.push({
            title: `${topic}のYahoo!ニュース`,
            description: `Yahoo!ニュースで「${topic}」を検索`,
            url: yahooNewsUrl,
            source: 'Yahoo!ニュース',
            timestamp: new Date().toISOString()
          });
          
        } catch (error) {
          console.error('News search error:', error);
        }
        
        return news;
      }
      
      // 翻訳API統合（無料版）
      async translateText(text, targetLang = 'en') {
        try {
          const cacheKey = `trans_${text}_${targetLang}`;
          const cached = this.translationCache.get(cacheKey);
          if (cached && Date.now() - cached.timestamp < this.cacheExpiry) {
            return cached.data;
          }
          
          // Google翻訳の簡易版（実際のAPIキーが必要）
          const translation = await this.simpleTranslation(text, targetLang);
          
          // キャッシュに保存
          this.translationCache.set(cacheKey, {
            data: translation,
            timestamp: Date.now()
          });
          
          return translation;
        } catch (error) {
          console.error('Translation API Error:', error);
          return text; // エラーの場合は原文を返す
        }
      }
      
      // 簡易翻訳（実際のAPIなし）
      async simpleTranslation(text, targetLang) {
        // 基本的な日本語→英語翻訳の例
        const basicTranslations = {
          'こんにちは': 'Hello',
          'ありがとう': 'Thank you',
          'おはよう': 'Good morning',
          'こんばんは': 'Good evening',
          'さようなら': 'Goodbye',
          'はい': 'Yes',
          'いいえ': 'No'
        };
        
        if (targetLang === 'en' && basicTranslations[text]) {
          return basicTranslations[text];
        }
        
        // 実際の翻訳APIがない場合は、翻訳サービスへのリンクを提供
        const googleTranslateUrl = `https://translate.google.com/?sl=ja&tl=${targetLang}&text=${encodeURIComponent(text)}`;
        
        return {
          translated: text,
          url: googleTranslateUrl,
          note: 'Google翻訳で詳細な翻訳を確認できます'
        };
      }
      
      // 知識ベース検索
      async searchKnowledgeBase(query) {
        const results = [];
        
        try {
          // Wikipedia検索
          const wikiResult = await this.getWikipediaInfo(query);
          if (wikiResult) {
            results.push({
              type: 'wikipedia',
              data: wikiResult,
              relevance: 0.9
            });
          }
          
          // ニュース検索
          const newsResults = await this.getLatestNews(query);
          if (newsResults.length > 0) {
            results.push({
              type: 'news',
              data: newsResults,
              relevance: 0.7
            });
          }
          
          // 結果を関連性でソート
          results.sort((a, b) => b.relevance - a.relevance);
          
          return results;
        } catch (error) {
          console.error('Knowledge base search error:', error);
          return [];
        }
      }
    }
    
    // 外部API統合システムのインスタンス化
    const externalAPI = new ExternalAPIIntegration();
    
    // ローカルAIシステム
    class LocalAISystem {
      constructor() {
        this.modelLoaded = false;
        this.modelName = 'rinna/japanese-gpt-neox-3.6b';
        this.maxTokens = 100;
        this.temperature = 0.7;
        this.fallbackResponses = this.buildFallbackResponses();
      }
      
      async initialize() {
        try {
          // Hugging Face Transformers.jsの読み込み確認
          if (typeof window.pipeline !== 'undefined') {
            await this.loadModel();
            this.modelLoaded = true;
            console.log('ローカルAIモデルが読み込まれました');
          } else {
            console.log('Transformers.jsが利用できません。フォールバックモードで動作します。');
          }
        } catch (error) {
          console.error('ローカルAI初期化エラー:', error);
        }
      }
      
      async loadModel() {
        try {
          // 軽量な日本語モデルの読み込み
          this.model = await window.pipeline('text-generation', this.modelName, {
            quantized: true,
            max_length: this.maxTokens
          });
        } catch (error) {
          console.error('モデル読み込みエラー:', error);
          throw error;
        }
      }
      
      async generateResponse(message, analysis, context) {
        try {
          if (this.modelLoaded && this.model) {
            return await this.generateWithModel(message, analysis, context);
          } else {
            return this.generateFallbackResponse(message, analysis, context);
          }
        } catch (error) {
          console.error('ローカルAI応答生成エラー:', error);
          return this.generateFallbackResponse(message, analysis, context);
        }
      }
      
      async generateWithModel(message, analysis, context) {
        const prompt = this.buildPrompt(message, analysis, context);
        
        const result = await this.model(prompt, {
          max_new_tokens: this.maxTokens,
          temperature: this.temperature,
          do_sample: true,
          pad_token_id: this.model.tokenizer.eos_token_id
        });
        
        return this.processModelOutput(result[0].generated_text, prompt);
      }
      
      buildPrompt(message, analysis, context) {
        let prompt = 'あなたは親切で賢いAIアシスタントです。\n\n';
        
        // 文脈情報の追加
        if (context.currentTopic) {
          prompt += `現在の話題: ${context.currentTopic}\n`;
        }
        
        if (context.userMood !== 'neutral') {
          prompt += `ユーザーの気分: ${context.userMood}\n`;
        }
        
        // 分析結果の追加
        if (analysis.emotions) {
          const dominantEmotion = this.getDominantEmotion(analysis.emotions);
          prompt += `感情分析: ${dominantEmotion}\n`;
        }
        
        prompt += `\nユーザー: ${message}\nAI: `;
        
        return prompt;
      }
      
      processModelOutput(generatedText, originalPrompt) {
        // プロンプト部分を除去
        let response = generatedText.replace(originalPrompt, '').trim();
        
        // 不要な改行や空白を整理
        response = response.replace(/\n+/g, '\n').trim();
        
        // 応答が短すぎる場合は拡張
        if (response.length < 10) {
          response = this.expandResponse(response);
        }
        
        return response;
      }
      
      getDominantEmotion(emotions) {
        let maxEmotion = 'neutral';
        let maxValue = 0;
        
        for (const [emotion, value] of Object.entries(emotions)) {
          if (value > maxValue) {
            maxValue = value;
            maxEmotion = emotion;
          }
        }
        
        const emotionNames = {
          'joy': '喜び',
          'sadness': '悲しみ',
          'anger': '怒り',
          'fear': '恐れ',
          'surprise': '驚き',
          'love': '愛情',
          'trust': '信頼',
          'confusion': '混乱',
          'excitement': '興奮'
        };
        
        return emotionNames[maxEmotion] || maxEmotion;
      }
      
      expandResponse(shortResponse) {
        const expansions = {
          'はい': 'はい、お手伝いできます。何かご質問はありますか？',
          'いいえ': 'いいえ、その通りではありません。詳しく説明させていただきます。',
          '分かりました': '分かりました。他に何かお手伝いできることはありますか？',
          'ありがとう': 'ありがとうございます。お役に立てて嬉しいです。'
        };
        
        return expansions[shortResponse] || shortResponse;
      }
      
      generateFallbackResponse(message, analysis, context) {
        // 分析結果に基づく適切なフォールバック応答
        if (analysis.intent === 'question') {
          return this.getQuestionFallback(analysis);
        } else if (analysis.intent === 'greeting') {
          return this.getGreetingFallback(context);
        } else if (analysis.sentiment === 'negative') {
          return this.getSupportiveFallback(analysis);
        } else {
          return this.getGeneralFallback(message, analysis);
        }
      }
      
      getQuestionFallback(analysis) {
        const questionResponses = {
          'specific': 'その質問について詳しく調べてみましょう。',
          'general': '興味深い質問ですね。一緒に考えてみましょう。',
          'opinion': '私の考えをお話しさせていただきますね。',
          'explanation': '分かりやすく説明させていただきます。'
        };
        
        return questionResponses[analysis.questionType] || '良い質問ですね。詳しくお答えします。';
      }
      
      getGreetingFallback(context) {
        const timeGreetings = {
          'morning': 'おはようございます！今日も一日頑張りましょう。',
          'afternoon': 'こんにちは！午後も頑張りましょう。',
          'evening': 'こんばんは！一日お疲れ様でした。',
          'night': '夜遅くまでお疲れ様です。ゆっくり休んでくださいね。'
        };
        
        return timeGreetings[context.timeOfDay] || 'こんにちは！何かお手伝いできることはありますか？';
      }
      
      getSupportiveFallback(analysis) {
        if (analysis.emotions.sadness > 5) {
          return 'お気持ち、よく分かります。一人で抱え込まないでくださいね。';
        } else if (analysis.emotions.anger > 5) {
          return 'お怒りの気持ち、理解できます。一緒に解決策を考えましょう。';
        } else if (analysis.emotions.fear > 5) {
          return '不安な気持ちですね。安心できる方法を一緒に考えましょう。';
        } else {
          return '大変な状況ですね。私にできることがあれば、いつでもお手伝いします。';
        }
      }
      
      getGeneralFallback(message, analysis) {
        const responses = [
          'そうですね。他に何かお手伝いできることはありますか？',
          '興味深いお話ですね。もっと詳しく聞かせてください。',
          '理解しました。他にご質問はありますか？',
          'なるほど、そうですね。何か他にお手伝いできることはありますか？'
        ];
        
        return responses[Math.floor(Math.random() * responses.length)];
      }
      
      buildFallbackResponses() {
        return {
          greeting: [
            'こんにちは！何かお手伝いできることはありますか？',
            'やあ！今日はどんな一日でしたか？',
            'こんにちは！お元気ですか？'
          ],
          question: [
            '良い質問ですね。詳しくお答えします。',
            'その質問について調べてみましょう。',
            '興味深い質問です。一緒に考えてみましょう。'
          ],
          support: [
            'お手伝いできることがあれば、いつでも言ってください。',
            '私にできることがあれば、全力でサポートします。',
            '困ったことがあれば、遠慮なくお声がけください。'
          ]
        };
      }
    }
    
    // ローカルAIシステムのインスタンス化
    const localAI = new LocalAISystem();
    
    // 初期化時にローカルAIを起動
    localAI.initialize();
    
    // 統合無料AI学習システムのメインクラス
    class IntegratedAILearningSystem {
      constructor() {
        this.emotionAnalyzer = new AdvancedEmotionAnalyzer();
        this.contextManager = advancedContextManager;
        this.patternMatcher = advancedPatternMatcher;
        this.externalAPI = externalAPI;
        this.localAI = localAI;
        this.learningData = learningData;
        this.userPreferences = userPreferences;
      }
      
      async processMessage(message, userId = 'default') {
        try {
          console.log('🔄 統合AI学習システム: メッセージ処理開始');
          
          // 1. 高度な感情・意図・トピック分析
          const analysis = this.analyzeMessage(message);
          console.log('📊 分析結果:', analysis);
          
          // 2. 文脈の理解と更新
          const context = this.contextManager.getContext(userId);
          console.log('🌐 文脈情報:', context);
          
          // 3. 知識ベース検索
          const knowledgeResults = await this.externalAPI.searchKnowledgeBase(message);
          console.log('📚 知識ベース結果:', knowledgeResults.length);
          
          // 4. 学習データからの応答生成
          const learnedResponse = this.generateLearnedResponse(message, analysis, context);
          console.log('🧠 学習ベース応答:', learnedResponse ? '生成済み' : 'なし');
          
          // 5. ローカルAIによる応答生成
          const aiResponse = await this.localAI.generateResponse(message, analysis, context);
          console.log('🤖 ローカルAI応答:', aiResponse ? '生成済み' : 'なし');
          
          // 6. 応答の統合と最適化
          const finalResponse = this.integrateResponses(learnedResponse, aiResponse, knowledgeResults, analysis);
          console.log('✨ 最終応答生成完了');
          
          // 7. 学習データの更新
          this.updateLearningData(message, finalResponse, analysis, context);
          
          // 8. コンテキストの更新
          this.contextManager.updateContext(userId, message, analysis, finalResponse);
          
          console.log('✅ 統合AI学習システム: メッセージ処理完了');
          
          return finalResponse;
        } catch (error) {
          console.error('❌ 統合AI学習システム エラー:', error);
          return this.getErrorResponse(error);
        }
      }
      
      analyzeMessage(message) {
        // 高度な感情分析
        const emotionResult = this.emotionAnalyzer.analyze(message);
        
        // 基本的な分析
        const basicAnalysis = analyzeUserMessage(message);
        
        // 分析結果の統合
        return {
          ...basicAnalysis,
          ...emotionResult,
          timestamp: new Date().toISOString(),
          messageLength: message.length,
          complexity: this.analyzeMessageComplexity(message)
        };
      }
      
      analyzeMessageComplexity(message) {
        const wordCount = message.split(/\s+/).length;
        const hasComplexStructures = /[、。！？]/.test(message);
        const hasEmojis = /[\u{1F600}-\u{1F64F}]/u.test(message);
        const hasURLs = /https?:\/\/[^\s]+/.test(message);
        
        let complexity = 0;
        if (wordCount > 20) complexity += 3;
        else if (wordCount > 10) complexity += 2;
        else complexity += 1;
        
        if (hasComplexStructures) complexity += 2;
        if (hasEmojis) complexity += 1;
        if (hasURLs) complexity += 2;
        
        if (complexity >= 6) return 'very_complex';
        if (complexity >= 4) return 'complex';
        if (complexity >= 2) return 'medium';
        return 'simple';
      }
      
      generateLearnedResponse(message, analysis, context) {
        try {
          // 高度なパターンマッチング
          const similarPattern = this.patternMatcher.findSimilarPattern(message, analysis, this.learningData);
          
          if (similarPattern && similarPattern.quality > 3) {
            return this.adaptResponseFromPattern(similarPattern, analysis, context);
          }
          
          // 従来の応答生成
          return selectResponsePattern(analysis);
        } catch (error) {
          console.error('学習ベース応答生成エラー:', error);
          return null;
        }
      }
      
      adaptResponseFromPattern(pattern, currentAnalysis, context) {
        let response = pattern.aiResponse;
        
        // 現在の文脈に合わせて応答を調整
        if (currentAnalysis.formality !== pattern.analysis?.formality) {
          if (currentAnalysis.formality === 'formal') {
            response = response.replace(/だよ/g, 'です').replace(/だね/g, 'ですね');
          } else {
            response = response.replace(/です/g, 'だよ').replace(/ますね/g, 'だね');
          }
        }
        
        // 感情レベルに合わせて調整
        if (currentAnalysis.emotionLevel > 3) {
          response = response.replace(/。/g, '！');
        } else if (currentAnalysis.emotionLevel < -3) {
          response = response.replace(/！/g, '。');
        }
        
        return response;
      }
      
      integrateResponses(learned, ai, knowledge, analysis) {
        let finalResponse = '';
        
        // 1. 知識ベース情報の統合
        if (knowledge && knowledge.length > 0) {
          finalResponse += this.integrateKnowledge(knowledge);
        }
        
        // 2. メイン応答の選択
        let mainResponse = '';
        if (learned && learned.length > 20) {
          mainResponse = learned;
        } else if (ai && ai.length > 10) {
          mainResponse = ai;
        } else {
          mainResponse = learned || ai || '申し訳ございません。適切な応答を生成できませんでした。';
        }
        
        finalResponse += mainResponse;
        
        // 3. 応答の最適化
        finalResponse = this.optimizeResponse(finalResponse, analysis);
        
        return finalResponse;
      }
      
      integrateKnowledge(knowledgeResults) {
        let knowledgeSection = '';
        
        // Wikipedia情報
        const wikiResult = knowledgeResults.find(result => result.type === 'wikipedia');
        if (wikiResult) {
          const wiki = wikiResult.data;
          knowledgeSection += `📚 **${wiki.title}**について\n\n`;
          knowledgeSection += `${wiki.extract}\n\n`;
          knowledgeSection += `詳細は[Wikipedia](${wiki.url})で確認できます。\n\n`;
        }
        
        // ニュース情報
        const newsResult = knowledgeResults.find(result => result.type === 'news');
        if (newsResult && newsResult.data.length > 0) {
          knowledgeSection += `📰 **最新ニュース**\n\n`;
          newsResult.data.slice(0, 2).forEach(news => {
            knowledgeSection += `• [${news.title}](${news.url})\n`;
          });
          knowledgeSection += `\n`;
        }
        
        return knowledgeSection;
      }
      
      optimizeResponse(response, analysis) {
        // 感情レベルに基づく最適化
        if (analysis.emotionLevel > 3) {
          response = response.replace(/。/g, '！');
        } else if (analysis.emotionLevel < -3) {
          response = response.replace(/！/g, '。');
        }
        
        // 複雑さに基づく最適化
        if (analysis.complexity === 'simple' && response.length > 100) {
          response = response.substring(0, 100) + '...';
        }
        
        return response;
      }
      
      updateLearningData(message, response, analysis, context) {
        try {
          // 会話パターンの学習
          const pattern = {
            userMessage: message,
            aiResponse: response,
            analysis: analysis,
            context: context,
            timestamp: new Date().toISOString(),
            quality: 0,
            id: Date.now()
          };
          
          this.learningData.conversationPatterns.push(pattern);
          
          // パターン数を制限
          if (this.learningData.conversationPatterns.length > 1000) {
            this.learningData.conversationPatterns = this.learningData.conversationPatterns.slice(-1000);
          }
          
          // セマンティックインデックスの更新
          this.patternMatcher.updateSemanticIndex(pattern);
          
          // 学習データの保存
          saveLearningData();
          
          console.log('💾 学習データ更新完了');
        } catch (error) {
          console.error('学習データ更新エラー:', error);
        }
      }
      
      getErrorResponse(error) {
        const errorResponses = [
          '申し訳ございません。一時的なエラーが発生しました。もう一度お試しください。',
          'システムエラーが発生しました。しばらく時間をおいてから再度お試しください。',
          '申し訳ございません。応答の生成中に問題が発生しました。'
        ];
        
        return errorResponses[Math.floor(Math.random() * errorResponses.length)];
      }
      
      // システム状態の取得
      getSystemStatus() {
        return {
          emotionAnalyzer: 'active',
          contextManager: 'active',
          patternMatcher: 'active',
          externalAPI: 'active',
          localAI: this.localAI.modelLoaded ? 'active' : 'fallback',
          learningData: this.learningData.conversationPatterns.length,
          cacheSize: this.patternMatcher.patternCache.size
        };
      }
      
      // 学習進捗の取得
      getLearningProgress() {
        const patterns = this.learningData.conversationPatterns;
        const highQualityPatterns = patterns.filter(p => p.quality > 3).length;
        
        return {
          totalPatterns: patterns.length,
          highQualityPatterns: highQualityPatterns,
          qualityRatio: patterns.length > 0 ? (highQualityPatterns / patterns.length) * 100 : 0,
          recentActivity: patterns.slice(-10).map(p => ({
            timestamp: p.timestamp,
            topic: p.analysis.topic,
            sentiment: p.analysis.sentiment
          }))
        };
      }
    }
    
    // 統合AI学習システムのインスタンス化
    const integratedAI = new IntegratedAILearningSystem();
    
    // aiReply関数を統合システムに置き換え（フォールバック付き）
    async function aiReply(text) {
      try {
        console.log('🤖 AI応答生成開始:', text);
        
        // 1. 基本的な会話応答を優先
        const basicResponse = generateBasicResponse(text);
        if (basicResponse && basicResponse !== '検索機能を使用します') {
          console.log('✅ 基本応答生成完了');
          return basicResponse;
        }
        
        // 2. 検索が必要な場合のみ検索を実行
        if (text.includes('検索') || text.includes('調べて') || text.includes('教えて') || text.includes('ニュース')) {
          console.log('🔍 検索機能を実行');
          const searchResponse = await executeSearch(text);
          if (searchResponse) {
            return searchResponse;
          }
        }
        
        // 3. 統合AIシステムを試行（軽量版）
        console.log('🧠 統合AIシステムを試行');
        const userId = localStorage.getItem('user_id') || 'default';
        const integratedResponse = await integratedAI.processMessage(text, userId);
        
        if (integratedResponse && integratedResponse.length > 0) {
          console.log('✅ 統合AI応答生成完了');
          return integratedResponse;
        }
        
        // 4. 最終フォールバック
        console.log('🔄 最終フォールバック: 基本応答生成を使用');
        return basicResponse || '申し訳ございません。適切な応答を生成できませんでした。';
        
      } catch (error) {
        console.error('❌ AI応答生成エラー:', error);
        
        // エラー時のフォールバック
        try {
          console.log('🔄 エラー時フォールバック: 基本応答生成を使用');
          return generateBasicResponse(text);
        } catch (fallbackError) {
          console.error('❌ フォールバックも失敗:', fallbackError);
          return '申し訳ございません。システムエラーが発生しました。しばらく時間をおいてから再度お試しください。';
        }
      }
    }
    
    // 検索実行関数
    async function executeSearch(text) {
      try {
        console.log('🔍 検索実行:', text);
        
        // 検索クエリの抽出
        let searchQuery = text;
        if (text.includes('検索')) {
          searchQuery = text.replace(/検索/, '').replace(/して/, '').trim();
        } else if (text.includes('調べて')) {
          searchQuery = text.replace(/調べて/, '').trim();
        } else if (text.includes('教えて')) {
          searchQuery = text.replace(/教えて/, '').trim();
        }
        
        // 短い単語の検索
        if (searchQuery.length <= 2) {
          const shortWordSearch = searchWeb(searchQuery);
          if (shortWordSearch) {
            return shortWordSearch;
          }
        }
        
        // 一般的な検索
        const searchResult = searchWeb(searchQuery);
        if (searchResult) {
          return searchResult;
        }
        
        return null;
      } catch (error) {
        console.error('検索実行エラー:', error);
        return null;
      }
    }
    
    // 基本的な応答生成（フォールバック用）
    function generateBasicResponse(text) {
      try {
        // 基本的な分析
        const analysis = analyzeUserMessage(text);
        
        // 検索意図の確認（基本応答では検索しない）
        if (text.includes('検索') || text.includes('調べて') || text.includes('教えて')) {
          return '検索機能を使用します';
        }
        
        // 時間・日付の確認
        if (text.includes('時間') || text.includes('何時') || text.includes('日付')) {
          const now = new Date();
          return `現在の時刻は${now.getHours()}時${now.getMinutes()}分です。日付は${now.getFullYear()}年${now.getMonth() + 1}月${now.getDate()}日です。`;
        }
        
        // 天気・気温の確認
        if (text.includes('天気') || text.includes('気温') || text.includes('暑い') || text.includes('寒い')) {
          return getWeatherFallback();
        }
        
        // 挨拶への応答
        if (text.includes('こんにちは') || text.includes('おはよう') || text.includes('こんばんは')) {
          const hour = new Date().getHours();
          const responses = {
            morning: [
              'おはようございます！今日も一日頑張りましょう！',
              'おはようございます！素晴らしい一日になりますように！',
              'おはようございます！今日も元気に過ごしましょう！'
            ],
            afternoon: [
              'こんにちは！午後も頑張りましょう！',
              'こんにちは！午後も充実した時間をお過ごしください！',
              'こんにちは！午後も元気に過ごしましょう！'
            ],
            evening: [
              'こんばんは！一日お疲れ様でした！',
              'こんばんは！今日も一日お疲れ様でした！',
              'こんばんは！ゆっくり休んでくださいね！'
            ],
            night: [
              '夜遅くまでお疲れ様です。ゆっくり休んでくださいね。',
              '夜遅くまでお疲れ様です。明日も頑張りましょう！',
              '夜遅くまでお疲れ様です。良い夢を見てくださいね。'
            ]
          };
          
          let timeCategory;
          if (hour >= 5 && hour < 12) timeCategory = 'morning';
          else if (hour >= 12 && hour < 17) timeCategory = 'afternoon';
          else if (hour >= 17 && hour < 21) timeCategory = 'evening';
          else timeCategory = 'night';
          
          const timeResponses = responses[timeCategory];
          return timeResponses[Math.floor(Math.random() * timeResponses.length)];
        }
        
        // 感謝への応答
        if (text.includes('ありがとう') || text.includes('感謝')) {
          const gratitudeResponses = [
            'どういたしまして！お役に立てて嬉しいです。他に何かお手伝いできることはありますか？',
            'どういたしまして！お役に立てて良かったです。他にも何かありますか？',
            'どういたしまして！お手伝いできて嬉しいです。何か他にご質問はありますか？',
            'どういたしまして！お役に立てて光栄です。他に何かお手伝いできることはありますか？'
          ];
          return gratitudeResponses[Math.floor(Math.random() * gratitudeResponses.length)];
        }
        
        // 感情に基づく応答
        if (analysis.emotions) {
          const dominantEmotion = getDominantEmotion(analysis.emotions);
          
          if (dominantEmotion === 'joy' && analysis.emotions.joy > 5) {
            const joyResponses = [
              'あなたの喜びが伝わってきます！何か良いことがあったのですね。',
              'それは素晴らしいですね！一緒に喜ばせてください。',
              'あなたの笑顔が目に浮かびます！何か良いことがあったのですね。'
            ];
            return joyResponses[Math.floor(Math.random() * joyResponses.length)];
          }
          
          if (dominantEmotion === 'sadness' && analysis.emotions.sadness > 5) {
            const sadnessResponses = [
              'お気持ち、よく分かります。一人で抱え込まないでくださいね。',
              '大丈夫ですか？何かお手伝いできることがあれば、いつでも言ってください。',
              'お気持ち、理解できます。一緒に解決策を考えましょう。'
            ];
            return sadnessResponses[Math.floor(Math.random() * sadnessResponses.length)];
          }
          
          if (dominantEmotion === 'anger' && analysis.emotions.anger > 5) {
            const angerResponses = [
              'お怒りの気持ち、理解できます。一緒に解決策を考えましょう。',
              'その気持ち、よく分かります。落ち着いて一緒に考えましょう。',
              'お怒りの気持ち、理解できます。何かお手伝いできることはありますか？'
            ];
            return angerResponses[Math.floor(Math.random() * angerResponses.length)];
          }
        }
        
        // 質問への応答
        if (text.includes('？') || text.includes('?')) {
          const questionResponses = [
            '良い質問ですね。詳しくお答えします。何について知りたいですか？',
            'それは興味深い質問です。一緒に考えてみましょう。',
            '良い質問ですね。何について詳しく知りたいですか？',
            'それは面白い質問です。詳しくお答えしますね。',
            '良い質問ですね。何についてお聞きになりたいですか？'
          ];
          return questionResponses[Math.floor(Math.random() * questionResponses.length)];
        }
        
        // より自然な会話応答
        const responses = [
          'そうですね。他に何かお手伝いできることはありますか？',
          '興味深いお話ですね。もっと詳しく聞かせてください。',
          '理解しました。何か他にご質問はありますか？',
          'なるほど、そうですね。何かお手伝いできることはありますか？',
          'お話ししてくださってありがとうございます。他にも何かありますか？',
          'それは面白いですね。他に何かお聞かせください。',
          'そうなんですね。他に何かお手伝いできることはありますか？',
          'おっしゃる通りです。何か他にご質問はありますか？',
          'それは良いですね。他にも何かお手伝いできることはありますか？',
          'なるほど、理解しました。他に何かありますか？'
        ];
        
        return responses[Math.floor(Math.random() * responses.length)];
        
      } catch (error) {
        console.error('基本応答生成エラー:', error);
        return '申し訳ございません。応答の生成中にエラーが発生しました。';
      }
    }
    
    // パターンからの応答適応
    function adaptResponseFromPattern(pattern, currentAnalysis) {
      let response = pattern.aiResponse;
      
      // 現在の文脈に合わせて応答を調整
      if (currentAnalysis.formality !== pattern.analysis.formality) {
        if (currentAnalysis.formality === 'formal') {
          response = response.replace(/だよ/g, 'です').replace(/だね/g, 'ですね');
        } else {
          response = response.replace(/です/g, 'だよ').replace(/ますね/g, 'だね');
        }
      }
      
      return response;
    }
    
    // 応答品質フィードバック
    function rateResponse(messageId, rating) {
      // 1-5のレーティング
      const pattern = learningData.conversationPatterns.find(p => p.messageId === messageId);
      if (pattern) {
        pattern.quality = rating;
        saveLearningData();
      }
    }
    
    // 学習設定UI
    function showLearningSettings() {
      const settingsHTML = `
        <div id="learning-settings" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
             background: #1a1a1a; padding: 20px; border-radius: 10px; border: 1px solid #333; z-index: 1000;">
          <h3 style="color: white; margin-top: 0;">🧠 AI学習設定</h3>
          

          
          <div style="margin: 10px 0;">
            <label style="color: white;">学習スタイル:</label><br>
            <select id="learning-style-select" style="padding: 5px; background: #333; color: white; border: 1px solid #555; border-radius: 4px;">
              <option value="adaptive" ${userPreferences.learningStyle === 'adaptive' ? 'selected' : ''}>適応型</option>
              <option value="pattern" ${userPreferences.learningStyle === 'pattern' ? 'selected' : ''}>パターン学習</option>
              <option value="contextual" ${userPreferences.learningStyle === 'contextual' ? 'selected' : ''}>文脈学習</option>
            </select>
          </div>
          
          <div style="margin: 10px 0;">
            <label style="color: white;">応答複雑度:</label><br>
            <select id="complexity-select" style="padding: 5px; background: #333; color: white; border: 1px solid #555; border-radius: 4px;">
              <option value="simple" ${userPreferences.responseComplexity === 'simple' ? 'selected' : ''}>シンプル</option>
              <option value="medium" ${userPreferences.responseComplexity === 'medium' ? 'selected' : ''}>標準</option>
              <option value="complex" ${userPreferences.responseComplexity === 'complex' ? 'selected' : ''}>複雑</option>
            </select>
          </div>
          
          <div style="margin: 10px 0;">
            <label style="color: white;">
              <input type="checkbox" id="auto-learn-checkbox" ${userPreferences.autoLearn ? 'checked' : ''}> 
              自動学習を有効化
            </label>
          </div>
          
          <div style="margin: 10px 0; color: #888;">
            学習データ: ${learningData.conversationPatterns.length}パターン<br>
            無料AI学習システム: アクティブ
          </div>
          
          <div style="margin-top: 20px;">
            <button onclick="saveLearningSettings()" style="padding: 10px 20px; margin-right: 10px; background: #333; color: white; border: none; border-radius: 5px;">保存</button>
            <button onclick="closeLearningSettings()" style="padding: 10px 20px; background: #555; color: white; border: none; border-radius: 5px;">キャンセル</button>
          </div>
        </div>
        <div id="settings-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;" onclick="closeLearningSettings()"></div>
      `;
      
      document.body.insertAdjacentHTML('beforeend', settingsHTML);
    }
    
    function saveLearningSettings() {
      userPreferences.learningStyle = document.getElementById('learning-style-select').value;
      userPreferences.responseComplexity = document.getElementById('complexity-select').value;
      userPreferences.autoLearn = document.getElementById('auto-learn-checkbox').checked;
      
      saveUserPreferences();
      closeLearningSettings();
      
      addMessage('system', ' 学習設定が保存されました！無料AI学習システムが最適化されます。');
    }
    
    function closeLearningSettings() {
      const settings = document.getElementById('learning-settings');
      const overlay = document.getElementById('settings-overlay');
      if (settings) settings.remove();
      if (overlay) overlay.remove();
    }
    
    // システム状態表示
    function showSystemStatus() {
      try {
        const status = integratedAI.getSystemStatus();
        const progress = integratedAI.getLearningProgress();
        
        const statusHTML = `
          <div id="system-status" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
               background: #1a1a1a; padding: 20px; border-radius: 10px; border: 1px solid #333; z-index: 1000; max-width: 500px;">
            <h3 style="color: white; margin-top: 0;">🔧 システム状態</h3>
            
            <div style="margin: 10px 0; color: white;">
              <strong>システムコンポーネント:</strong><br>
              • 感情分析: ${status.emotionAnalyzer}<br>
              • 文脈管理: ${status.contextManager}<br>
              • パターンマッチング: ${status.patternMatcher}<br>
              • 外部API: ${status.externalAPI}<br>
              • ローカルAI: ${status.localAI}<br>
              • 学習データ: ${status.learningData}パターン<br>
              • キャッシュサイズ: ${status.cacheSize}件
            </div>
            
            <div style="margin: 10px 0; color: white;">
              <strong>学習進捗:</strong><br>
              • 総パターン数: ${progress.totalPatterns}<br>
              • 高品質パターン: ${progress.highQualityPatterns}<br>
              • 品質比率: ${progress.qualityRatio.toFixed(1)}%<br>
              • 最近の活動: ${progress.recentActivity.length}件
            </div>
            
            <div style="margin: 10px 0; color: #888;">
              <strong>デバッグ情報:</strong><br>
              • ブラウザ: ${navigator.userAgent.substring(0, 50)}...<br>
              • タイムスタンプ: ${new Date().toLocaleString('ja-JP')}
            </div>
            
            <div style="margin-top: 20px;">
              <button onclick="closeSystemStatus()" style="padding: 10px 20px; background: #333; color: white; border: none; border-radius: 5px;">閉じる</button>
            </div>
          </div>
          <div id="status-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;" onclick="closeSystemStatus()"></div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', statusHTML);
        
      } catch (error) {
        console.error('システム状態表示エラー:', error);
        alert('システム状態の取得中にエラーが発生しました。');
      }
    }
    
    function closeSystemStatus() {
      const status = document.getElementById('system-status');
      const overlay = document.getElementById('status-overlay');
      if (status) status.remove();
      if (overlay) overlay.remove();
    }
    
    // 初期化時に学習データを読み込み
    loadLearningData();
  </script>
</body>
</html>